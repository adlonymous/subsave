{"version":3,"sources":["../src/api/grid-api-client.ts","../src/types/common.ts","../src/utils/validation.ts","../src/utils/crypto/privy-crypto.ts","../src/utils/crypto/solana-crypto.ts","../src/utils/crypto/turnkey-crypto.ts","../src/managers/authentication-manager.ts","../src/config/default-config.ts","../src/utils/period-mapper.ts","../src/providers/base-provider.ts","../src/utils/crypto/hpke-chacha-rn.ts","../src/providers/privy-provider.ts","../src/providers/turnkey-provider.ts","../src/managers/signing-manager.ts","../src/core/grid-client.ts"],"names":["_GridApiClient","config","_endpoint","endpoint","options","method","data","headers","url","requestHeaders","response","responseText","result","errorMessage","errorDetails","error","params","request","apiRequest","address","transactionId","payload","smartAccountAddress","submitPayload","queryParams","accountAddress","spendingLimitAddress","passkeyAddress","admin","kycId","standingOrderId","__name","GridApiClient","_AuthorizationError","message","code","provider","cause","details","timestamp","requestId","formatted","suggestions","detail","s","docs","AuthorizationError","_ProviderError","statusCode","ProviderError","_ValidationUtils","intent","PublicKey","signer","index","operation","validTypes","publicKey","email","sanitized","ValidationUtils","sha256","KEM_ID","KDF_ID","AEAD_ID","i2osp2","n","b","concat","arrs","len","a","out","off","createPKCS8PrivateKey","privateKeyBytes","header","ecPrivateKey","createSPKIPublicKey","publicKeyBytes","algorithmId","bitStringHeader","totalLength","spki","generateHPKEKeyPair","p256","spkiPublicKey","pkcs8PrivateKey","Buffer","extractPrivateKeyFromDER","derBytes","i","signPayload","authorizationKey","decodedKmsPayload","signaturePayload","serializedPayload","canonicalize","serializedPayloadBuffer","base64Key","hash","derSignature","generateSolanaKeyPair","Keypair","generateTurnkeyKeyPair","generateP256KeyPair","keyPair","decryptCredentials","credentials","privateKey","decryptCredentialBundle","getPublicKeyFromDecryptedData","getPublicKey","uint8ArrayToHexString","uint8ArrayFromHexString","signWithApiKey","input","createHash","_AuthenticationManager","apiClient","authType","providers","keyPairs","type","tag","hpkeKeyPair","solanaKp","passkeyKp","expiration","authKeyPair","keypair","passkeyId","otpCode","user","sessionSecrets","privyKeypair","kp","privyRequest","turnkeyKeypair","turnkeyRequest","AuthenticationManager","DEFAULT_CONFIG","getGridConfig","overrides","apiKey","gridToProgram","gridToProgramPeriod","period","mapped","_AbstractBaseProvider","providerType","requestPayload","transactionSigners","AbstractBaseProvider","HPKE_VERSION","SUITE_ID_1","SUITE_ID_2","LABEL_EAE_PRK","LABEL_SHARED_SECRET","LABEL_SECRET","LABEL_BASE_NONCE","isCompressed","hpkeChachaDecrypt","ciphertextBuf","encappedKeyBuf","receiverPriv","ss","deriveSS","receiverPubBuf","kemContext","labeledIkm","buildHpkeCoreLabeledIkm","labeledInfo","buildHpkeCoreLabeledInfo","kemSharedSecret","extractAndExpand","mode","psk","pskId","info","pskIdHash","webCryptoLabeledExtract","infoHash","keyScheduleContext","secretLabeledIkm","buildWebCryptoLabeledIkm","keyLabeledInfo","buildWebCryptoLabeledInfo","key","webCryptoExtractAndExpand","nonceLabeledInfo","baseNonce","chachaDecrypt","hpkeChachaDecryptRN","encryptedAuthKey","recipientPrivateKeyBase64","base64ToUint8Array","pkcs8Buffer","rawPrivateKey","extractPrivateKeyFromPKCS8Bytes","label","ikm","suiteId","combinedLength","ret","offset","salt","saltBytes","ikmBytes","infoBytes","prk","sharedSecret","resp","priv","encryptedData","nonce","aad","chacha20poly1305","base64","binaryString","bytes","_PrivyProvider","privyKeys","res","transaction","signers","firstSigner","decryptedBytes","decryptedAuthKey","_request","PrivyProvider","_TurnkeyProvider","turnkeyKeys","decryptedData","signature","TurnkeyProvider","_SigningManager","requestedSigners","transactionBuffer","versionedTransaction","VersionedTransaction","accountKeys","signatures","signerPubkey","signerIndex","byte","pubkey","kmsPayloads","session","signedTransaction","unsignedSigners","kmsPayload","solanaKeypair","privySession","authKey","serializedTransaction","keypairs","transaction_signers","nonSessionKeypairs","selected","sessionEntry","authenticatedWallets","sortedPrivyKeypairs","wallet","roleOrder","selectedPrivyKeypair","sortedTurnkeyKeypairs","selectedTurnkeyKeypair","eoaKeypairs","primaryKeypairs","signerAddress","providerFound","sortedKeypairs","selectedKeypair","SigningManager","_GridClient","apiConfig","transactionData","preparedTxBuffer","externallySignedTransaction","authRequest","targetProvider","signRequest","transactionResult","signedTransactionPayload","kms_payloads","apiData","transactionPayload","cleanedResponse","updates","GridClient"],"mappings":"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","file":"index.mjs","sourcesContent":["import {\n  CreatePasskeySessionRequest,\n  CreatePasskeySessionResponse,\n  TurnkeyInitAuthRequest,\n  TurnkeyCompleteAuthRequest,\n  ConfirmPayload,\n  PrivyInitAuthRequest,\n  PrivyCompleteAuthRequest,\n  SpendingLimitRequest,\n  GetPasskeysResponse,\n  AddPasskeyRequest,\n  AddPasskeyQueryParams,\n  AddPasskeyResponse,\n  UpdateAccountRequest,\n  CreateAccountRequest,\n  CreateAccountResponse,\n  GetAccountResponse,\n  GetAccountBalancesQueryParams,\n  GetAccountBalancesResponse,\n  GetTransfersOptions,\n  GetTransfersResponse,\n  CreatePaymentIntentRequest,\n  CreatePaymentIntentApiResponse,\n  UpdateSpendingLimitRequest,\n  UseSpendingLimitRequest,\n  RequestKycLinkRequest,\n  RequestKycLinkResponse,\n  GetKycStatusResponse,\n  PrepareArbitraryTransactionRequest,\n  PrepareArbitraryTransactionQueryParams,\n  RemovePasskeyRequest,\n  RemovePasskeyQueryParams,\n  RemovePasskeyResponse,\n  RequestVirtualAccountRequest,\n  RequestVirtualAccountResponse,\n  GetVirtualAccountsQueryParams,\n  GetVirtualAccountsResponse,\n  CreateStandingOrderRequest,\n  CreateStandingOrderResponse,\n  GetStandingOrdersQueryParams,\n  GetStandingOrdersResponse,\n  GetStandingOrderResponse,\n  GridTransactionResponse,\n  ApiSpendingLimitRequest,\n  SignersAccountRequest,\n} from \"../types\";\nimport { PrivyInternalSignRequest } from \"../types/privy\";\nimport * as uuid from \"uuid\";\n\nexport interface ApiResponse<T = any> {\n  success: boolean;\n  data?: T;\n  error?: string;\n  code?: string;\n  details?: any; // Raw details from API response\n  timestamp?: string; // Error timestamp from backend\n  requestId?: string; // Request ID for tracking\n}\n\nexport type GridEnvironment = \"sandbox\" | \"production\";\n\nexport interface GridApiConfig {\n  apiKey?: string; // Optional so you can use it to generate Keypairs without exposing your API key\n  environment: GridEnvironment;\n  baseUrl: string;\n  timeout?: number;\n  retryAttempts?: number;\n  solanaRpcUrl?: string; // Optional Solana RPC endpoint for convenience\n}\n\nexport class GridApiClient {\n  private environment: GridEnvironment;\n  private config: GridApiConfig;\n  private baseUrl: string;\n\n  constructor(config: GridApiConfig) {\n    // Validate environment if provided\n    if (\n      config.environment &&\n      ![\"sandbox\", \"production\"].includes(config.environment)\n    ) {\n      throw new Error(\n        `Invalid Grid environment: '${config.environment}'. Must be 'sandbox' or 'production'.`\n      );\n    }\n\n    if (!config.baseUrl) {\n      throw new Error(\"Base URL is required\");\n    }\n\n    this.environment = config.environment || \"sandbox\";\n    this.baseUrl = `${config.baseUrl}/api/grid/v1`;\n    this.config = {\n      timeout: 10000,\n      retryAttempts: 3,\n      ...config,\n    };\n\n    // Log warning if no API key is provided\n    if (!this.config.apiKey) {\n      console.warn(\n        \"⚠️ GridApiClient initialized without API key. Only local operations (generateKeyPair, generateSessionSecrets, context management) will be available. API operations will fail until an API key is provided.\"\n      );\n    }\n  }\n\n  private generateIdempotencyKey(): string {\n    return uuid.v4();\n  }\n\n  /**\n   * Check if API key is available\n   */\n  public hasApiKey(): boolean {\n    return Boolean(this.config.apiKey);\n  }\n\n  /**\n   * Determine if an endpoint requires API authentication\n   * Endpoints that don't require API key are typically for local operations only\n   */\n  private requiresApiKey(_endpoint: string): boolean {\n    // All actual API endpoints require authentication\n    // This method exists for future extensibility if needed\n    return true;\n  }\n\n  protected async request<T>(\n    endpoint: string,\n    options: {\n      method?: \"GET\" | \"POST\" | \"PUT\" | \"DELETE\" | \"PATCH\";\n      data?: any;\n      headers?: Record<string, string>;\n    } = {}\n  ): Promise<ApiResponse<T>> {\n    const { method = \"GET\", data, headers = {} } = options;\n\n    // Check if this endpoint requires API key and throw error if missing\n    if (this.requiresApiKey(endpoint) && !this.config.apiKey) {\n      return {\n        success: false,\n        error: \"API key is required for this operation. Initialize GridClient with an API key to use this feature. Operations that don't require an API key: generateKeyPair(), generateSessionSecrets(), getContext(), updateContext(), clearAuthContext()\",\n        code: \"API_KEY_REQUIRED\",\n      };\n    }\n\n    const url = `${this.baseUrl}${endpoint}`;\n    const requestHeaders: Record<string, string> = {\n      \"Content-Type\": \"application/json\",\n      \"x-grid-environment\": this.environment,\n      ...headers,\n    };\n\n    // Add idempotency key for POST/PUT/PATCH requests\n    if (method === \"POST\" || method === \"PUT\" || method === \"PATCH\") {\n      requestHeaders[\"x-idempotency-key\"] = this.generateIdempotencyKey();\n    }\n\n    // Only add Authorization header if API key is provided\n    if (this.config.apiKey) {\n      requestHeaders[\"Authorization\"] = `Bearer ${this.config.apiKey}`;\n    }\n\n    try {\n      const response = await fetch(url, {\n        method,\n        headers: requestHeaders,\n        body: data ? JSON.stringify(data) : undefined,\n        // signal: AbortSignal.timeout(this.config.timeout!)\n      });\n      console.log('⭐ response', response);\n\n      // Get response as text first, then try to parse as JSON\n      const responseText = await response.text();\n      console.log('⭐ responseText', responseText);\n      let result: any;\n\n      try {\n        result = JSON.parse(responseText);\n        console.log('⭐ result', result);\n      } catch (jsonError) {\n        // If response is not JSON, return the text as error\n        return {\n          success: false,\n          error: responseText || \"Invalid response format\",\n          code: response.status.toString(),\n        };\n      }\n\n      if (!response.ok) {\n        // Parse error details from response body\n        const errorMessage =\n          result?.message || response.statusText || \"API request failed\";\n        const errorDetails = result?.details || result;\n\n        return {\n          success: false,\n          error: errorMessage,\n          code: response.status.toString(),\n          details: errorDetails,\n          timestamp: result?.timestamp,\n          requestId: result?.request_id,\n        };\n      }\n\n      return {\n        success: true,\n        data: result.data ? result.data : result,\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : \"Unknown error\",\n        code: \"NETWORK_ERROR\",\n      };\n    }\n  }\n\n  // Passkey session creation\n  async createPasskeySession(\n    params: CreatePasskeySessionRequest\n  ): Promise<ApiResponse<CreatePasskeySessionResponse>> {\n    return this.request<CreatePasskeySessionResponse>(\"/api/v1/passkeys\", {\n      method: \"POST\",\n      headers: {\n        \"x-squads-network\": params.env,\n      },\n      data: params,\n    });\n  }\n\n  // Auth endpoints\n  async initAuthWithTurnkey(\n    request: TurnkeyInitAuthRequest\n  ): Promise<ApiResponse<any>> {\n    // Transform camelCase to snake_case for API\n    const apiRequest = {\n      email: request.email,\n      app_name: request.appName,\n      app_icon_url: request.appIconUrl,\n      expiration: request.expiration,\n    };\n\n    return this.request<any>(\"/auth/init\", {\n      method: \"POST\",\n      data: apiRequest,\n    });\n  }\n\n  async completeTurnkeyAuth(\n    data: TurnkeyCompleteAuthRequest\n  ): Promise<ApiResponse<any>> {\n    const apiRequest = {\n      mpc_primary_id: data.mpcPrimaryId,\n      otp_id: data.otpId,\n      otp_code: data.otpCode,\n      auth_public_key: data.authPublicKey,\n      expiration: data.expiration,\n    };\n    return this.request<any>(\"/auth/complete\", {\n      method: \"POST\",\n      data: apiRequest,\n    });\n  }\n\n  async completeTurnkeyAuthAndCreateAccount(\n    data: TurnkeyCompleteAuthRequest\n  ): Promise<ApiResponse<any>> {\n    const apiRequest = {\n      mpc_primary_id: data.mpcPrimaryId,\n      otp_id: data.otpId,\n      otp_code: data.otpCode,\n      auth_public_key: data.authPublicKey,\n      expiration: data.expiration,\n    };\n    return this.request<any>(\"/auth/complete-and-create-account\", {\n      method: \"POST\",\n      data: apiRequest,\n    });\n  }\n\n  // Privy Auth endpoints\n  async initAuthWithPrivy(\n    request: PrivyInitAuthRequest\n  ): Promise<ApiResponse<any>> {\n    const apiRequest = {\n      email: request.email,\n      provider: request.provider || \"privy\",\n      expiration: request.expiration,\n    };\n\n    return this.request<any>(\"/auth\", {\n      method: \"POST\",\n      data: apiRequest,\n    });\n  }\n\n  async completePrivyAuthAndCreateAccount(\n    data: PrivyCompleteAuthRequest\n  ): Promise<ApiResponse<any>> {\n    const apiRequest = {\n      email: data.email,\n      otp_code: data.otpCode,\n      provider: \"privy\",\n      kms_provider_config: {\n        encryption_public_key: data.authPublicKey,\n      },\n      expiration: data.expiration,\n    };\n    return this.request<any>(\"/accounts/verify\", {\n      method: \"POST\",\n      data: apiRequest,\n    });\n  }\n\n  async completePrivyAuth(\n    data: PrivyCompleteAuthRequest\n  ): Promise<ApiResponse<any>> {\n    const apiRequest = {\n      email: data.email,\n      otp_code: data.otpCode,\n      kms_provider: \"privy\",\n      kms_provider_config: {\n        encryption_public_key: data.authPublicKey,\n      },\n      expiration: data.expiration,\n    };\n\n    return this.request<any>(\"/auth/verify\", {\n      method: \"POST\",\n      data: apiRequest,\n    });\n  }\n\n  // Transaction endpoints (crypto-native terminology)\n  async sendTransaction(\n    address: string,\n    transactionId: string,\n    payload: ConfirmPayload\n  ): Promise<ApiResponse<any>> {\n    const endpoint = `/accounts/${address}/transactions/${transactionId}/confirm?use-mpc-provider=true`;\n\n    return this.request<any>(endpoint, {\n      method: \"POST\",\n      data: payload,\n    });\n  }\n\n  // Submit transaction with KMS payloads format (for Privy)\n  async submitPrivyTransaction(\n    smartAccountAddress: string,\n    submitPayload: any\n  ): Promise<ApiResponse<any>> {\n    const endpoint = `/accounts/${smartAccountAddress}/submit`;\n\n    return this.request<any>(endpoint, {\n      method: \"POST\",\n      data: submitPayload,\n    });\n  }\n\n  // Generic transaction submission\n  async submitTransaction(\n    smartAccountAddress: string,\n    submitPayload: any\n  ): Promise<ApiResponse<any>> {\n    const endpoint = `/accounts/${smartAccountAddress}/submit`;\n\n    return this.request<any>(endpoint, {\n      method: \"POST\",\n      data: submitPayload,\n    });\n  }\n\n  // Account endpoints\n  async getAccount(address: string): Promise<ApiResponse<GetAccountResponse>> {\n    return this.request<GetAccountResponse>(`/accounts/${address}`, {\n      method: \"GET\",\n    });\n  }\n\n  async getTransactions(address: string): Promise<ApiResponse<any>> {\n    return this.request<any>(`/accounts/${address}/transactions`, {\n      method: \"GET\",\n    });\n  }\n\n  async getAccountBalances(\n    address: string,\n    queryParams?: GetAccountBalancesQueryParams\n  ): Promise<ApiResponse<GetAccountBalancesResponse>> {\n    let endpoint = `/accounts/${address}/balances`;\n\n    // Add query parameters if provided\n    if (queryParams) {\n      const params = new URLSearchParams();\n      if (queryParams.limit !== undefined) {\n        params.append(\"limit\", queryParams.limit.toString());\n      }\n      if (queryParams.page !== undefined) {\n        params.append(\"page\", queryParams.page.toString());\n      }\n      if (params.toString()) {\n        endpoint += `?${params.toString()}`;\n      }\n    }\n\n    return this.request<GetAccountBalancesResponse>(endpoint, {\n      method: \"GET\",\n    });\n  }\n\n  async getTransfers(\n    address: string,\n    options?: GetTransfersOptions\n  ): Promise<ApiResponse<GetTransfersResponse>> {\n    let endpoint = `/accounts/${address}/transfers`;\n\n    // Add query parameters if provided\n    if (options) {\n      const params = new URLSearchParams();\n      if (options.payment_rail !== undefined) {\n        params.append(\"type\", options.payment_rail); // API uses 'type' parameter\n      }\n      if (options.status !== undefined) {\n        params.append(\"status\", options.status);\n      }\n      if (options.currency !== undefined) {\n        params.append(\"currency\", options.currency);\n      }\n      if (options.start_date !== undefined) {\n        params.append(\"start_date\", options.start_date);\n      }\n      if (options.end_date !== undefined) {\n        params.append(\"end_date\", options.end_date);\n      }\n      if (options.tx_hash !== undefined) {\n        params.append(\"tx_hash\", options.tx_hash);\n      }\n      if (options.limit !== undefined) {\n        params.append(\"limit\", options.limit.toString());\n      }\n      if (options.cursor !== undefined) {\n        params.append(\"cursor\", options.cursor);\n      }\n      if (params.toString()) {\n        endpoint += `?${params.toString()}`;\n      }\n    }\n\n    return this.request<GetTransfersResponse>(endpoint, {\n      method: \"GET\",\n    });\n  }\n\n  // Legacy method for backward compatibility\n  async getBalance(\n    address: string\n  ): Promise<ApiResponse<GetAccountBalancesResponse>> {\n    return this.getAccountBalances(address);\n  }\n\n  // Spending limit endpoint\n  async createSpendingLimit(\n    smartAccountAddress: string,\n    request: ApiSpendingLimitRequest\n  ): Promise<ApiResponse<GridTransactionResponse>> {\n    const endpoint = `/accounts/${smartAccountAddress}/spending-limit`;\n\n    return this.request<GridTransactionResponse>(endpoint, {\n      method: \"POST\",\n      data: request,\n    });\n  }\n\n  // Update spending limit endpoint\n  async updateSpendingLimit(\n    accountAddress: string,\n    spendingLimitAddress: string,\n    request: UpdateSpendingLimitRequest\n  ): Promise<ApiResponse<GridTransactionResponse>> {\n    const endpoint = `/accounts/${accountAddress}/spending-limit/${spendingLimitAddress}`;\n\n    return this.request<GridTransactionResponse>(endpoint, {\n      method: \"PATCH\",\n      data: request,\n    });\n  }\n\n  // Delete spending limit endpoint\n  async deleteSpendingLimit(\n    accountAddress: string,\n    spendingLimitAddress: string\n  ): Promise<ApiResponse<GridTransactionResponse>> {\n    const endpoint = `/accounts/${accountAddress}/spending-limit/${spendingLimitAddress}`;\n\n    return this.request<GridTransactionResponse>(endpoint, {\n      method: \"DELETE\",\n      data: {\n        transaction_signers: [],\n      },\n    });\n  }\n\n  // Use spending limit endpoint\n  async useSpendingLimit(\n    accountAddress: string,\n    spendingLimitAddress: string,\n    request: UseSpendingLimitRequest\n  ): Promise<ApiResponse<GridTransactionResponse>> {\n    const endpoint = `/accounts/${accountAddress}/spending-limit/${spendingLimitAddress}/transactions`;\n\n    return this.request<GridTransactionResponse>(endpoint, {\n      method: \"POST\",\n      data: request,\n    });\n  }\n\n  // Passkey endpoints\n  async getPasskeys(\n    accountAddress: string\n  ): Promise<ApiResponse<GetPasskeysResponse>> {\n    const endpoint = `/accounts/${accountAddress}/passkeys`;\n\n    return this.request<GetPasskeysResponse>(endpoint, {\n      method: \"GET\",\n    });\n  }\n\n  async addPasskey(\n    accountAddress: string,\n    request: AddPasskeyRequest,\n    queryParams?: AddPasskeyQueryParams\n  ): Promise<ApiResponse<AddPasskeyResponse>> {\n    const endpoint = `/accounts/${accountAddress}/passkeys/transaction`;\n    const params = queryParams?.admin ? \"?admin=true\" : \"\";\n\n    return this.request<AddPasskeyResponse>(endpoint + params, {\n      method: \"POST\",\n      data: request,\n    });\n  }\n\n  async removePasskey(\n    accountAddress: string,\n    passkeyAddress: string,\n    request: RemovePasskeyRequest,\n    queryParams?: RemovePasskeyQueryParams\n  ): Promise<ApiResponse<RemovePasskeyResponse>> {\n    const endpoint = `/accounts/${accountAddress}/passkeys/${passkeyAddress}/transaction`;\n    const params = queryParams?.admin ? \"?admin=true\" : \"\";\n\n    return this.request<RemovePasskeyResponse>(endpoint + params, {\n      method: \"DELETE\",\n      data: request,\n    });\n  }\n\n  // Account creation endpoint\n  async createAccount(\n    request: CreateAccountRequest\n  ): Promise<ApiResponse<CreateAccountResponse>> {\n    const endpoint = \"/accounts\";\n\n    return this.request<CreateAccountResponse>(endpoint, {\n      method: \"POST\",\n      data: request,\n    });\n  }\n\n  // Account update endpoint\n  async updateAccount(\n    accountAddress: string,\n    request: UpdateAccountRequest,\n    admin?: boolean,\n  ): Promise<ApiResponse<GridTransactionResponse>> {\n    const endpoint = `/accounts/${accountAddress}`;\n    const params = admin ? \"?admin=true\" : \"\";\n\n    return this.request<GridTransactionResponse>(endpoint + params, {\n      method: \"PATCH\",\n      data: request,\n    });\n  }\n\n  // Payment intent endpoint\n  async createPaymentIntent(\n    accountAddress: string,\n    request: CreatePaymentIntentRequest\n  ): Promise<ApiResponse<CreatePaymentIntentApiResponse>> {\n    const endpoint = `/accounts/${accountAddress}/payment-intent`;\n\n    return this.request<CreatePaymentIntentApiResponse>(endpoint, {\n      method: \"POST\",\n      data: request,\n    });\n  }\n\n  // Request KYC Link endpoint\n  async requestKycLink(\n    accountAddress: string,\n    request: RequestKycLinkRequest\n  ): Promise<ApiResponse<RequestKycLinkResponse>> {\n    const endpoint = `/accounts/${accountAddress}/kyc`;\n\n    return this.request<RequestKycLinkResponse>(endpoint, {\n      method: \"POST\",\n      data: request,\n    });\n  }\n\n  // Get KYC Status endpoint\n  async getKycStatus(\n    accountAddress: string,\n    kycId: string\n  ): Promise<ApiResponse<GetKycStatusResponse>> {\n    const endpoint = `/accounts/${accountAddress}/kyc/${kycId}`;\n\n    return this.request<GetKycStatusResponse>(endpoint, {\n      method: \"GET\",\n    });\n  }\n\n  // Prepare Arbitrary Transaction endpoint\n  async prepareArbitraryTransaction(\n    accountAddress: string,\n    request: PrepareArbitraryTransactionRequest,\n    queryParams?: PrepareArbitraryTransactionQueryParams\n  ): Promise<ApiResponse<GridTransactionResponse>> {\n    let endpoint = `/accounts/${accountAddress}/transactions`;\n\n    // Add query parameters if provided\n    if (queryParams) {\n      const params = new URLSearchParams();\n      if (queryParams.debug !== undefined) {\n        params.append(\"debug\", queryParams.debug.toString());\n      }\n      if (params.toString()) {\n        endpoint += `?${params.toString()}`;\n      }\n    }\n\n    return this.request<GridTransactionResponse>(endpoint, {\n      method: \"POST\",\n      data: request,\n    });\n  }\n\n  // Request Virtual Account endpoint\n  async requestVirtualAccount(\n    accountAddress: string,\n    request: RequestVirtualAccountRequest\n  ): Promise<ApiResponse<RequestVirtualAccountResponse>> {\n    const endpoint = `/accounts/${accountAddress}/virtual-account`;\n\n    return this.request<RequestVirtualAccountResponse>(endpoint, {\n      method: \"POST\",\n      data: request,\n    });\n  }\n\n  // Get Virtual Accounts endpoint\n  async getVirtualAccounts(\n    accountAddress: string,\n    queryParams?: GetVirtualAccountsQueryParams\n  ): Promise<ApiResponse<GetVirtualAccountsResponse>> {\n    let endpoint = `/accounts/${accountAddress}/virtual-accounts`;\n\n    // Add query parameters if provided\n    if (queryParams) {\n      const params = new URLSearchParams();\n      if (queryParams.source_currency !== undefined) {\n        params.append(\"source_currency\", queryParams.source_currency);\n      }\n      if (queryParams.destination_currency !== undefined) {\n        params.append(\"destination_currency\", queryParams.destination_currency);\n      }\n      if (params.toString()) {\n        endpoint += `?${params.toString()}`;\n      }\n    }\n\n    return this.request<GetVirtualAccountsResponse>(endpoint, {\n      method: \"GET\",\n    });\n  }\n\n  // Create Standing Order endpoint\n  async createStandingOrder(\n    accountAddress: string,\n    request: CreateStandingOrderRequest\n  ): Promise<ApiResponse<CreateStandingOrderResponse>> {\n    const endpoint = `/accounts/${accountAddress}/standing-order-intent`;\n\n    const res = await this.request<CreateStandingOrderResponse>(endpoint, {\n      method: \"POST\",\n      data: request,\n    });\n    return res;\n  }\n\n  // Get Standing Orders endpoint\n  async getStandingOrders(\n    accountAddress: string,\n    queryParams?: GetStandingOrdersQueryParams\n  ): Promise<ApiResponse<GetStandingOrdersResponse>> {\n    let endpoint = `/accounts/${accountAddress}/standing-orders`;\n\n    // Add query parameters if provided\n    if (queryParams) {\n      const params = new URLSearchParams();\n      if (queryParams.status !== undefined) {\n        params.append(\"status\", queryParams.status);\n      }\n      if (queryParams.currency !== undefined) {\n        params.append(\"currency\", queryParams.currency);\n      }\n      if (queryParams.start_date !== undefined) {\n        params.append(\"start_date\", queryParams.start_date);\n      }\n      if (queryParams.end_date !== undefined) {\n        params.append(\"end_date\", queryParams.end_date);\n      }\n      if (queryParams.tx_hash !== undefined) {\n        params.append(\"tx_hash\", queryParams.tx_hash);\n      }\n      if (queryParams.limit !== undefined) {\n        params.append(\"limit\", queryParams.limit.toString());\n      }\n      if (queryParams.cursor !== undefined) {\n        params.append(\"cursor\", queryParams.cursor);\n      }\n\n      if (params.toString()) {\n        endpoint += `?${params.toString()}`;\n      }\n    }\n\n    return this.request<GetStandingOrdersResponse>(endpoint, {\n      method: \"GET\",\n    });\n  }\n\n  // Get Single Standing Order endpoint\n  async getStandingOrder(\n    accountAddress: string,\n    standingOrderId: string\n  ): Promise<ApiResponse<GetStandingOrderResponse>> {\n    const endpoint = `/accounts/${accountAddress}/standing-order/${standingOrderId}`;\n\n    return this.request<GetStandingOrderResponse>(endpoint, {\n      method: \"GET\",\n    });\n  }\n\n  // Signing endpoints\n  async signWithPrivy(\n    request: PrivyInternalSignRequest\n  ): Promise<ApiResponse<{ signature: string }>> {\n    const endpoint = \"/sign/privy\";\n\n    return this.request<{ signature: string }>(endpoint, {\n      method: \"POST\",\n      data: request,\n    });\n  }\n\n  async signWithTurnkey(\n    request: any\n  ): Promise<ApiResponse<{ signature: string }>> {\n    const endpoint = \"/sign/turnkey\";\n\n    return this.request<{ signature: string }>(endpoint, {\n      method: \"POST\",\n      data: request,\n    });\n  }\n\n  async signWithPasskey(\n    request: any\n  ): Promise<ApiResponse<{ signature: string }>> {\n    const endpoint = \"/sign/passkey\";\n\n    return this.request<{ signature: string }>(endpoint, {\n      method: \"POST\",\n      data: request,\n    });\n  }\n}\n","import { Keypair } from '@solana/web3.js';\nimport { TurnkeyConfig } from './turnkey';\nimport { PasskeyConfig } from './passkey';\nimport { SolanaConfig } from './solana';\nimport { PrivyConfig } from './privy';\nimport { GridApiClient, GridApiConfig, GridEnvironment } from '../api/grid-api-client';\nimport { SignResult, TransactionPayload, TransactionResult } from '../managers/signing-manager';\n\n\n\n/////////// Providers ///////////\n\nexport interface ProviderConfig {\n  apiKey?: string;\n  apiUrl?: string;\n  timeout?: number;\n  retryAttempts?: number;\n  metadata?: Record<string, unknown>;\n  environment?: string; // Auto-injected from factory function\n}\n\nexport type AuthProvider = 'turnkey' | 'passkey' | 'solana' | 'privy';\n\nexport interface AuthProviderOptions {\n  provider: AuthProvider;\n  config?: TurnkeyConfig | PasskeyConfig | SolanaConfig | PrivyConfig;\n}\n\n\n\n/////////// Errors ///////////\n\nexport interface ErrorDetail {\n  field?: string;\n  code: string;\n  message: string;\n  suggestion: string;\n  documentation: string;\n}\n\nexport class AuthorizationError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly provider?: AuthProvider,\n    public readonly cause?: Error,\n    public readonly details?: ErrorDetail[],\n    public readonly timestamp?: string,\n    public readonly requestId?: string\n  ) {\n    super(message);\n    this.name = 'AuthorizationError';\n  }\n\n  // Helper method to format error with suggestions\n  getFormattedMessage(): string {\n    let formatted = this.message;\n\n    if (this.details && this.details.length > 0) {\n      const suggestions = this.details\n        .filter(detail => detail.suggestion && detail.suggestion.trim())\n        .map(detail => detail.suggestion);\n\n      if (suggestions.length > 0) {\n        formatted += `\\n\\nSuggestions:\\n${suggestions.map(s => `• ${s}`).join('\\n')}`;\n      }\n\n      const docs = this.details\n        .filter(detail => detail.documentation && detail.documentation.trim())\n        .map(detail => detail.documentation);\n\n      if (docs.length > 0) {\n        formatted += `\\n\\nDocumentation: ${docs[0]}`;\n      }\n    }\n\n    return formatted;\n  }\n}\n\nexport class CustomError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string,\n    public readonly cause?: Error\n  ) {\n    super(message);\n    this.name = 'CustomError';\n  }\n}\n\nexport class ProviderError extends Error {\n  constructor(\n    message: string,\n    public readonly provider: AuthProvider,\n    public readonly statusCode?: number,\n    public readonly cause?: Error,\n    public readonly details?: ErrorDetail[],\n    public readonly timestamp?: string,\n    public readonly requestId?: string\n  ) {\n    super(message);\n    this.name = 'ProviderError';\n  }\n\n  // Helper method to format error with suggestions\n  getFormattedMessage(): string {\n    let formatted = this.message;\n\n    if (this.details && this.details.length > 0) {\n      const suggestions = this.details\n        .filter(detail => detail.suggestion && detail.suggestion.trim())\n        .map(detail => detail.suggestion);\n\n      if (suggestions.length > 0) {\n        formatted += `\\n\\nSuggestions:\\n${suggestions.map(s => `• ${s}`).join('\\n')}`;\n      }\n\n      const docs = this.details\n        .filter(detail => detail.documentation && detail.documentation.trim())\n        .map(detail => detail.documentation);\n\n      if (docs.length > 0) {\n        formatted += `\\n\\nDocumentation: ${docs[0]}`;\n      }\n    }\n\n    return formatted;\n  }\n}\n\n/////////// Key Management ///////////\n\nexport interface UniversalKeyPair {\n  publicKey: string;\n  privateKey: string;\n}\n\nexport type KeyPairTag = 'primary' | 'backup' | 'solana' | 'passkey';\n\nexport interface TaggedKeyPair extends UniversalKeyPair {\n  provider: SignerProvider;\n  tag: KeyPairTag;\n}\n\nexport type SessionSecrets = TaggedKeyPair[];\n\n/////////// Types / Enums ///////////\n\nexport type Env = 'devnet' | 'mainnet' | 'testnet';\n\n\n/////////// Authentication ///////////\n\nexport interface InitAuthRequest {\n  email?: string;\n  expiration?: number;\n}\n\nexport interface InitAuthResponse {\n  data: any;\n}\n\nexport interface CompleteAuthRequest {\n  expiration?: number;\n}\n\nexport interface CompleteAuthRequestWithOtp extends CompleteAuthRequest {\n  otpCode: string;\n  user: GridClientUserContext;\n  sessionSecrets: SessionSecrets;\n}\n\nexport interface CompleteAuthResponse {\n  data: any;\n}\n\nexport interface CompleteAuthAndCreateAccountRequest {\n  otpCode: string;\n  user: GridClientUserContext;\n  sessionSecrets: SessionSecrets;\n}\n\nexport interface SignRequest {\n  transaction: string;\n  sessionSecrets: SessionSecrets;\n  // session?: any; // Generic session type, can be PrivySessionData or other provider sessions\n}\n\nexport interface SubmitRequest {\n  transaction: string;\n  kms_payloads: KmsPayload[];\n}\n\nexport interface SendTransactionRequest {\n  signedTransactionPayload: TransactionResult;\n  address: string;\n}\n\n\n// Grid-specific payment intent types\nexport interface ConfirmPayload {\n  intentPayload: string;\n  mpcPayload: string;\n}\n\n// Spending Limit types\nexport type SpendingLimitPeriod = 'one_time' | 'daily' | 'weekly' | 'monthly';\nexport type ApiSpendingLimitPeriod = 'one_time' | 'day' | 'week' | 'month';\n\nexport interface ApiSpendingLimitRequest {\n  amount: string | number;\n  mint: string;\n  period: ApiSpendingLimitPeriod;\n  transaction_signers?: string[];\n  spending_limit_signers: string[];\n}\n\nexport interface SpendingLimitRequest {\n  amount: string | number;\n  mint: string;\n  period: SpendingLimitPeriod;\n  transaction_signers?: string[];\n  spending_limit_signers: string[];\n  destinations?: string[];\n  expiration?: number;\n}\n\n// GridTransactionResponse - unified response type for common transaction operations\nexport interface GridTransactionResponse {\n  data?: TransactionPayload | any;\n  error?: string;\n}\n\n// Passkey types - available to all providers\nexport type PasskeyPermission = string; // Specific permissions as strings\n\nexport interface PasskeyInfo {\n  address: string;\n  role: string;\n  permissions: PasskeyPermission[];\n  provider: string;\n  added_at: string; // DateTime<Utc> maps to ISO string\n}\n\nexport interface GetPasskeysResponse {\n  account_address: string;\n  passkey: PasskeyInfo | null; // Option<PasskeyInfo> maps to T | null\n}\n\nexport interface PasskeyInput {\n  address: string;\n  role?: string; // Optional, defaults in Rust\n  permissions?: PasskeyPermission[]; // Optional, defaults in Rust\n}\n\nexport interface AddPasskeyRequest {\n  passkey: PasskeyInput;\n  transaction_signers?: string[]; // Optional, from Option<Vec<Pubkey>>\n}\n\nexport interface AddPasskeyQueryParams {\n  admin?: boolean; // Optional, defaults to false\n}\n\nexport interface AddPasskeyResponse {\n  transaction: string;\n  passkey: PasskeyInfo; // Reuse existing PasskeyInfo type\n  threshold: number; // u8 maps to number\n  status: string;\n  expires_at: string; // DateTime<Utc> maps to ISO string\n}\n\n// Update Account types\nexport type SignerRole = 'primary' | 'backup';\nexport type SignerPermission = 'CAN_INITIATE' | 'CAN_EXECUTE' | 'CAN_VOTE';\n\nexport interface AccountSigner {\n  address: string;\n  role: SignerRole;\n  permissions: SignerPermission[];\n  provider: string;  // 'privy' | 'passkey' | 'external' etc.\n}\n\nexport interface UpdateAccountRequest {\n  signers?: AccountSigner[]; // Optional Vec<AccountSigner> maps to optional array\n  threshold?: number; // Optional u16 maps to optional number\n  time_lock?: number; // Optional u32 maps to optional number\n  admin_address?: string | null; // Patch<Pubkey> maps to optional string or null\n  transaction_signers?: string[]; // Optional Vec<Pubkey> maps to optional string array\n}\n\n// Minimal user input for createAccount - ultra-simple interface\nexport interface CreateAccountInput {\n  email?: string;    // For email-based accounts\n  signer?: string;   // For signer-based accounts (Solana public key)\n}\n\n// Internal Rust-matching payload types (for API communication)\nexport interface AccountPolicies {\n  signers: AccountSigner[];           // 1-10 signers (Rust validation)\n  threshold: number;                  // 1-10, must be <= signers.length\n  time_lock?: number | null;          // Optional, 1-u32::MAX if provided\n  admin_address?: string | null;      // Optional Pubkey\n}\n\nexport interface EmailPayload {\n  email: string;                      // Required, validated email format\n}\n\nexport interface SignersPayload {\n  policies: AccountPolicies;          // Required account policies\n  grid_user_id?: string | null;       // Optional UUID\n}\n\n// Rust enum-style discriminated union for API\nexport interface EmailAccountRequest {\n  type: 'email';\n  email: string;\n}\n\nexport interface SignersAccountRequest {\n  type: 'signers';\n  policies: AccountPolicies;\n  grid_user_id?: string | null;\n  memo?: string;\n}\n\nexport type CreateAccountRequest = EmailAccountRequest | SignersAccountRequest | AccountPolicies;\n\nexport interface EmailAccountResponse {\n  type: 'email';\n  email: string;\n  status: string;\n  otp_sent: boolean;\n  created_at: string;\n  expires_at: string;\n  memo?: string;\n}\n\nexport interface SignersAccountResponse {\n  type: 'signers';\n  address: string;\n  policies: AccountPolicies;\n  grid_user_id: string;\n  memo?: string;\n}\n\nexport type CreateAccountResponse = EmailAccountResponse | SignersAccountResponse;\n\n// Get Account types\nexport interface GetAccountResponse {\n  data: {\n    type: 'signers' | 'email';\n    address: string;\n    policies?: AccountPolicies; // Optional for email accounts\n    grid_user_id: string;\n    memo?: string;\n    created_at?: string;\n    status?: string; // For email accounts\n  }\n}\n\n// Get Account Balances types\nexport interface TokenBalance {\n  token_address: string;\n  amount: bigint;\n  decimals: number;\n  amount_decimal: string;\n  symbol?: string;\n  name?: string;\n  logo?: string;\n}\n\nexport interface GetAccountBalancesQueryParams {\n  limit?: number; // Default: 10\n  page?: number;  // Default: 1\n}\n\n// Account balances data structure\nexport interface AccountBalancesData {\n  address: string;\n  lamports: bigint; // u64 maps to number in TypeScript\n  sol: number;      // f64 maps to number in TypeScript\n  tokens: TokenBalance[];\n}\n\nexport interface GetAccountBalancesResponse {\n  data?: AccountBalancesData;\n  error?: string;\n}\n\n// Create Payment Intent types\nexport interface PaymentDetails {\n  account?: string;               // For source\n  address?: string;               // For destination (crypto)\n  currency: string;\n  payment_rail?: string;          // For destination (fiat) - e.g., \"ach_push\"\n  external_account_id?: string;   // For destination (fiat)\n}\n\nexport interface CreatePaymentIntentRequest {\n  amount: string;\n  grid_user_id: string;\n  source: PaymentDetails;\n  destination: PaymentDetails;\n  webhook_url?: string;\n}\n\n// Raw API response from server (matches Rust struct)\nexport type CreatePaymentIntentApiResponse = any;\n\n// Client response (follows standard data pattern)\nexport interface CreatePaymentIntentResponse {\n  data?: {\n    transactionPayload?: TransactionPayload;\n  } & Omit<CreatePaymentIntentApiResponse, 'kms_payloads' | 'transaction_signers' | 'transaction'>;\n  error?: string;\n}\n\n// Update Spending Limit types\nexport interface KmsPayload {\n  provider: string;\n  address: string;\n  payload: string;\n}\n\nexport interface UpdateSpendingLimitRequest {\n  amount?: string | number;        // Option<u64> with validation min = 1\n  mint?: string;                   // Option<Pubkey>\n  period?: SpendingLimitPeriod;    // Option<Period> - reuse existing type\n  spending_limit_signers?: string[]; // Patch<Vec<Pubkey>>\n  destinations?: string[];         // Patch<Vec<Pubkey>>\n  expiration?: number;             // Patch<i64>\n  transaction_signers?: string[];  // Vec<Pubkey>\n}\n\n// Use Spending Limit types\nexport interface UseSpendingLimitRequest {\n  amount: string | number;        // u64 with validation min = 1, str_or_u64\n  signer_address: string;         // Pubkey\n  recipient_address: string;      // Pubkey\n}\n\n// Request KYC Link types\nexport type KycType = 'individual' | 'business';\nexport type KycEndorsement = 'ach' | 'sepa';\n\nexport interface RequestKycLinkRequest {\n  grid_user_id: string;          // Uuid\n  type: KycType;                 // BridgeCustomerType (renamed from kyc_type)\n  email: string;\n  full_name: string;\n  endorsements?: KycEndorsement[]; // Vec<String> with validation\n  redirect_uri?: string;          // Option<String>\n}\n\nexport interface KycLink {\n  id: string;\n  full_name: string;\n  email: string;\n  type: KycType;\n  kyc_link: string;\n  tos_link: string;\n  kyc_status: KycStatus;\n  rejection_reasons: string[];\n  tos_status: TosStatus;\n  created_at: string;\n  customer_id: string;\n  persona_inquiry_type: string;\n}\n\nexport interface RequestKycLinkResponse {\n  data?: KycLink;\n  error?: string;\n}\n\n// Get KYC Status types\nexport type KycStatus = 'pending' | 'approved' | 'rejected' | 'under_review';\nexport type TosStatus = 'pending' | 'approved' | 'rejected';\n\nexport interface RejectionReason {\n  code: string;\n  message: string;\n}\n\n// KYC status data structure\nexport interface KycStatusData {\n  id: string;\n  account: string;              // Pubkey mapped to string\n  type: KycType;               // BridgeCustomerType - reuse existing type\n  status: KycStatus;\n  tos_status: TosStatus;\n  kyc_continuation_link?: string; // Option<String>\n  rejection_reasons: RejectionReason[]; // Vec<RejectionReason> with default empty\n  requirements_due: string[];   // Vec<String> with default empty\n  created_at: string;           // DateTime<Utc> mapped to ISO string\n  updated_at: string;           // DateTime<Utc> mapped to ISO string\n}\n\nexport interface GetKycStatusResponse {\n  data?: KycStatusData;\n  error?: string;\n}\n\n// Fee configuration types\nexport type Currency = 'sol' | 'usdc' | 'usdt' | 'pyusd' | 'eurc';\n\nexport interface FeeConfig {\n  currency?: Currency;         // Option<Currency>\n  payer_address: string;       // Pubkey mapped to string\n  self_managed_fees?: boolean; // Option<bool>\n}\n\n// Prepare Arbitrary Transaction types\nexport interface PrepareArbitraryTransactionRequest {\n  transaction: string;          // String with validation length(min = 1)\n  /**\n   * @deprecated Use account_signers instead\n   */\n  transaction_signers?: string[]; // Vec<Pubkey> mapped to string array (optional with default empty)\n  account_signers?: string[]; // Vec<Pubkey> mapped to string array (optional with default empty)\n  /**\n   * @deprecated Use fee_config instead\n   */\n  payer_address?: string;       // Option<String>\n  fee_config?: FeeConfig;       // Option<FeeConfig>\n}\n\nexport interface PrepareArbitraryTransactionQueryParams {\n  debug?: boolean;              // Optional debug flag with default false\n}\n\n// Remove Passkey types\nexport interface RemovePasskeyRequest {\n  transaction_signers?: string[]; // Option<Vec<Pubkey>> mapped to string array\n}\n\nexport interface RemovePasskeyQueryParams {\n  admin?: boolean;              // Optional admin flag with default false\n}\n\nexport interface RemovePasskeyResponse {\n  transaction: string;\n  removed_passkey: PasskeyInfo; // Reuse existing PasskeyInfo type\n  threshold: number;            // u8 mapped to number\n  status: string;\n  expires_at: string;           // DateTime<Utc> mapped to ISO string\n}\n\n// Transfer types for payment intents\nexport interface TransferSourceDepositInstructions {\n  // Instructions for source deposit - structure to be defined based on API\n  [key: string]: any;\n}\n\nexport interface TransferSource {\n  // Source transfer details - structure to be defined based on API\n  [key: string]: any;\n}\n\nexport interface TransferDestination {\n  // Destination transfer details - structure to be defined based on API\n  [key: string]: any;\n}\n\nexport type TransferState = \n  | 'awaiting_funds'\n  | 'in_review' \n  | 'funds_received'\n  | 'payment_submitted'\n  | 'payment_processed'\n  | 'canceled'\n  | 'error'\n  | 'undeliverable'\n  | 'returned'\n  | 'refunded';\n\n// Comprehensive Transfer types for get_transfers endpoint\nexport type ConfirmationStatus = 'pending' | 'confirmed';\nexport type TransferDirection = 'inflow' | 'outflow';\n\nexport interface Receipt {\n  id: string;\n  object: string;\n  created_at: string; // ISO string from DateTime<Utc>\n}\n\n// Bridge Transfer types (matching bridge::Transfer)\nexport interface BridgeTransferSource {\n  payment_rail: PaymentRail;\n  currency: BridgeCurrency;\n  external_account_id?: string;\n  bridge_wallet_id?: string;\n  from_address?: string;\n  omad?: string;\n  imad?: string;\n  bank_beneficiary_name?: string;\n}\n\nexport interface BridgeTransferDestination {\n  currency: BridgeCurrency;\n  payment_rail: PaymentRail;\n  external_account_id?: string;\n  bridge_wallet_id?: string;\n  from_address?: string;\n  wire_message?: string;\n  sepa_reference?: string;\n  swift_reference?: string;\n}\n\nexport interface BridgeTransferSourceDepositInstructions {\n  amount?: string; // Decimal from Rust\n  currency: BridgeCurrency;\n  deposit_message?: string;\n  payment_rail: PaymentRail;\n  from_address?: string;\n  to_address?: string;\n  bank_name?: string;\n  bank_address?: string;\n  bank_city?: string;\n  bank_country?: string;\n  bank_postal_code?: string;\n  iban?: string;\n  swift_bic?: string;\n  beneficiary_name?: string;\n  beneficiary_address?: string;\n  beneficiary_city?: string;\n  beneficiary_country?: string;\n  beneficiary_postal_code?: string;\n  routing_number?: string;\n  account_number?: string;\n  account_type?: string;\n}\n\nexport interface BridgeTransfer {\n  id: string;\n  state: TransferState;\n  on_behalf_of: string;\n  source_deposit_instructions?: BridgeTransferSourceDepositInstructions;\n  amount: string; // Decimal from Rust\n  client_reference_id?: string;\n  currency?: BridgeCurrency;\n  developer_fee: string; // Decimal from Rust\n  source: BridgeTransferSource;\n  destination: BridgeTransferDestination;\n  receipt: Receipt;\n  blockchain_memo?: string;\n  created_at: string; // ISO string from DateTime<Utc>\n  updated_at: string; // ISO string from DateTime<Utc>\n}\n\n// SPL Transfer types (matching postgres_models::GridSplTransfer)\nexport interface SplTransfer {\n  id: string;\n  grid_user_id: string;\n  main_account_address: string;\n  mint: string;\n  is_token_2022: boolean;\n  signature: string;\n  confirmation_status: ConfirmationStatus;\n  from_address: string;\n  to_address: string;\n  amount: string;\n  ui_amount: string;\n  decimals: number;\n  confirmed_at?: string; // ISO string from NaiveDateTime\n  created_at: string; // ISO string from NaiveDateTime\n  updated_at: string; // ISO string from NaiveDateTime\n  direction?: TransferDirection;\n  environment?: GridEnvironment;\n  instruction_index?: number;\n}\n\n// Union type for transfer responses\nexport type TransferResponse = BridgeTransfer | SplTransfer;\n\n// Options for get_transfers endpoint\nexport interface GetTransfersOptions {\n  payment_rail?: PaymentRail; // renamed from 'type' to avoid TypeScript keyword\n  status?: TransferState;\n  currency?: BridgeCurrency;\n  start_date?: string;\n  end_date?: string;\n  tx_hash?: string;\n  limit?: number;\n  cursor?: string;\n}\n\n// Response type for get_transfers endpoint\nexport interface GetTransfersResponse {\n  data?: TransferResponse[];\n  error?: string;\n}\n\n// Request Virtual Account types\nexport type BridgeCurrency = 'usd' | 'eur';\n\nexport interface RequestVirtualAccountRequest {\n  grid_user_id: string;         // Uuid mapped to string\n  currency: BridgeCurrency;     // BridgeCurrency enum\n}\n\nexport interface SourceDepositInstructions {\n  currency: string;\n  bank_beneficiary_name: string;\n  bank_name: string;\n  bank_address: string;\n  bank_routing_number: string;\n  bank_account_number: string;\n  payment_rails: string[];\n}\n\nexport interface VirtualAccountDestination {\n  currency: string;\n  payment_rail: string;\n  address: string;\n}\n\nexport interface VirtualAccount {\n  id: string;\n  customer_id: string;\n  source_deposit_instructions: SourceDepositInstructions;\n  destination: VirtualAccountDestination;\n  status: string;\n  developer_fee_percent: string;\n}\n\nexport interface RequestVirtualAccountResponse {\n  data?: VirtualAccount;\n  error?: string;\n}\n\n// Get Virtual Accounts types\nexport interface GetVirtualAccountsQueryParams {\n  source_currency?: BridgeCurrency;      // Optional BridgeCurrency filter\n  destination_currency?: BridgeCurrency; // Optional BridgeCurrency filter\n}\n\nexport interface GetVirtualAccountsResponse {\n  data?: VirtualAccount[];  // Array of virtual accounts\n  error?: string;\n}\n\n// Standing Order types\nexport type StandingOrderFrequency = 'weekly' | 'monthly';\nexport type StandingOrderStatus = 'active' | 'inactive' | 'cancelled' | 'completed';\nexport type PaymentRail = 'ach_push' | 'ach_pull' | 'sepa' | 'faster_payments' | 'wire' | 'solana' | 'smart_account';\n\n// Details types matching Rust structure\nexport interface GridAccountDetails {\n  account: string;\n  currency: string;\n  transaction_signers?: string[]; // Optional array of signer pubkeys\n}\n\nexport interface SolanaDetails {\n  address: string;\n  currency: string;\n}\n\nexport interface NewExternalAccountDetails {\n  payment_rail: PaymentRail;\n  currency: string;\n  details: any; // CreateExternalAccountRequest - would need proper typing\n}\n\nexport interface ExistingExternalAccountDetails {\n  payment_rail: PaymentRail;\n  currency: string;\n  external_account_id: string;\n}\n\n// Untagged union matching Rust's Details enum with #[serde(untagged)]\n// The type is determined by the presence of specific fields\nexport type Details =\n  | GridAccountDetails           // has 'account' field\n  | SolanaDetails                // has 'address' field\n  | NewExternalAccountDetails    // has 'details' field\n  | ExistingExternalAccountDetails; // has 'external_account_id' field\n\nexport interface CreateStandingOrderRequest {\n  amount: string;\n  grid_user_id: string;\n  source: Details;\n  destination: Details;\n  frequency: StandingOrderFrequency;\n  start_date: string; // ISO date string\n  end_date?: string; // Optional ISO date string\n}\n\nexport interface CreateStandingOrderResponse {\n  data?: {\n    id: string;\n    amount: string;\n    ui_amount: string;\n    currency: BridgeCurrency;\n    payment_rail: PaymentRail;\n    source: Details;\n    destination: Details;\n    frequency: StandingOrderFrequency;\n    start_date: string;\n    end_date?: string;\n    status: StandingOrderStatus;\n    transaction: string; // transaction\n    kms_payloads: KmsPayload[];\n    transaction_signers: string[];\n    valid_until: string;\n    created_at: string;\n    transactionPayload: TransactionPayload;\n  };\n  error?: string;\n}\n\n// Get Standing Orders types\nexport interface GetStandingOrdersQueryParams {\n  status?: StandingOrderStatus;\n  currency?: string;  // BridgeCurrency as string\n  start_date?: string;\n  end_date?: string;\n  tx_hash?: string;\n  limit?: number;\n  cursor?: string;\n}\n\nexport interface StandingOrder {\n  id: string;\n  amount: string;\n  currency: string;\n  period: StandingOrderFrequency;\n  destinations: string[];\n  status: StandingOrderStatus;\n  remaining_amount: string;\n  last_execution_date?: string;  // ISO date string\n  next_execution_date: string;    // ISO date string\n  created_at: string;             // ISO date string\n}\n\nexport interface GetStandingOrdersResponse {\n  data?: StandingOrder[];\n  error?: string;\n}\n\n// Get Single Standing Order types\nexport interface GetStandingOrderResponse {\n  data?: StandingOrder;\n  error?: string;\n}\n\n// User Data Encryption types\nexport interface UserDataEncryptionOptions {\n  encryptionKey: string; // 64-character hex string (32 bytes)\n}\n\nexport interface EncryptedUserData {\n  encryptedData: string; // Base64 encoded encrypted JSON\n  timestamp?: number; // Optional timestamp when encrypted\n}\n\n// Grid Client Signer types\nexport type SignerProvider = 'privy' | 'turnkey' | 'solana' | 'passkey' | 'pending' | 'external';\n\nexport interface GridClientSigner {\n  address?: string;               // Optional - Solana/passkey signers have address\n  email?: string;                 // Optional - Privy/Turnkey signers may have email\n  sessionKey?: any;\n  type: 'primary' | 'backup';     // Signer priority/role\n  provider?: SignerProvider;      // Optional - The provider type for this signer\n}\n\n// Grid Client Context types\nexport interface GridClientUserContext {\n  // data: {\n    address?: string;          // The single smart account address (once created)\n    grid_user_id?: string;           // Grid platform user ID\n    signers: GridClientSigner[];  // Array of all signers who can authorize transactions\n    session?: Session;\n    email?: string;\n  // }\n}\n\n// Session types from AuthenticateResponse\nexport interface EncryptedAuthorizationKey {\n  encryption_type: string;\n  encapsulated_key: string;\n  ciphertext: string;\n}\n\nexport type WalletChainType =\n  | 'Solana'\n  | 'Ethereum'\n  | 'Cosmos'\n  | 'Stellar'\n  | 'Sui'\n  | 'Tron'\n  | 'bitcoin-segwit';\n\nexport interface AdditionalSigner {\n  signer_id: string;\n  override_policy_ids?: string[]; // Optional Vec<String>\n}\n\nexport interface Wallet {\n  id: string;\n  address: string;\n  public_key?: string; // Option<String>\n  created_at: number; // u64\n  chain_type: WalletChainType;\n  policy_ids: string[];\n  owner_id?: string; // Option<String>\n  additional_signers: AdditionalSigner[];\n  exported_at?: number; // Option<u64>\n  imported_at?: number; // Option<u64>\n}\n\nexport interface Session {\n  encrypted_authorization_key?: EncryptedAuthorizationKey; // Option<EncryptedAuthorizationKey>\n  authorization_key?: string; // Option<String>\n  expires_at: number; // u64\n  wallets: Wallet[];\n}\n\nexport interface GridClientSessionContext {\n  user_id?: string;\n  session?: Session\n}\n\nexport interface ClientContext {\n  environment: GridEnvironment;\n  config: GridApiConfig;\n  solanaRpcUrl?: string;\n}\n\nexport interface GridClientContext {\n  client: ClientContext;\n  user: GridClientUserContext;\n}\n\n// User data encryption types for context-aware operations\nexport interface ContextualUserData {\n  userId: string;\n  email?: string;\n  smartAccount: string;\n  data: any;\n  timestamp: string;\n  dataType?: string; // e.g., 'preferences', 'settings', 'custom'\n}\n","import { PublicKey } from '@solana/web3.js';\nimport { AuthProviderOptions, TurnkeyConfig, PasskeyConfig, SolanaConfig, ProviderConfig, AuthorizationError } from '../types';\n\nexport class ValidationUtils {\n  static validateProviderOptions(options: AuthProviderOptions): void {\n    if (!options) {\n      throw new AuthorizationError('Provider options are required', 'INVALID_OPTIONS');\n    }\n\n    if (!options.provider) {\n      throw new AuthorizationError('Provider type is required', 'MISSING_PROVIDER_TYPE');\n    }\n\n    // Config is now optional - only validate if provided\n    if (options.config) {\n      switch (options.provider) {\n        case 'turnkey':\n          this.validateTurnkeyConfig(options.config as TurnkeyConfig);\n          break;\n        case 'passkey':\n          this.validatePasskeyConfig(options.config as PasskeyConfig);\n          break;\n        case 'solana':\n          this.validateSolanaConfig(options.config as SolanaConfig);\n          break;\n        default:\n          throw new AuthorizationError(\n            `Unknown provider type: ${options.provider}`,\n            'UNKNOWN_PROVIDER',\n            options.provider\n          );\n      }\n    }\n  }\n\n  static validateTurnkeyConfig(config: TurnkeyConfig): void {\n    // TurnkeyConfig now only uses base ProviderConfig fields\n    this.validateBaseProviderConfig(config);\n  }\n\n  static validateBaseProviderConfig(config: ProviderConfig): void {\n    if (config.timeout && (config.timeout < 1000 || config.timeout > 300000)) {\n      throw new AuthorizationError('Timeout must be between 1000ms and 300000ms', 'INVALID_TIMEOUT');\n    }\n\n  }\n\n  static validatePasskeyConfig(config: PasskeyConfig): void {\n    // PasskeyConfig now only uses base ProviderConfig fields\n    this.validateBaseProviderConfig(config);\n  }\n\n  static validateSolanaConfig(config: SolanaConfig): void {\n    // SolanaConfig now only uses base ProviderConfig fields\n    this.validateBaseProviderConfig(config);\n  }\n\n  static validateAuthorizationIntent(intent: any): void {\n    if (!intent) {\n      throw new AuthorizationError('Authorization intent is required', 'MISSING_INTENT');\n    }\n\n    if (!intent.address) {\n      throw new AuthorizationError('Smart account address is required', 'MISSING_SMART_ACCOUNT');\n    }\n\n    try {\n      new PublicKey(intent.address);\n    } catch (error) {\n      throw new AuthorizationError('Invalid smart account address', 'INVALID_SMART_ACCOUNT');\n    }\n\n    if (!intent.operation) {\n      throw new AuthorizationError('Operation is required', 'MISSING_OPERATION');\n    }\n\n    this.validateSmartAccountOperation(intent.operation);\n\n    if (intent.signers) {\n      intent.signers.forEach((signer: any, index: number) => {\n        try {\n          new PublicKey(signer);\n        } catch (error) {\n          throw new AuthorizationError(`Invalid signer address at index ${index}`, 'INVALID_SIGNER');\n        }\n      });\n    }\n  }\n\n  private static validateSmartAccountOperation(operation: any): void {\n    if (!operation.type) {\n      throw new AuthorizationError('Operation type is required', 'MISSING_OPERATION_TYPE');\n    }\n\n    const validTypes = ['transfer', 'swap', 'stake', 'custom'];\n    if (!validTypes.includes(operation.type)) {\n      throw new AuthorizationError(\n        `Invalid operation type. Must be one of: ${validTypes.join(', ')}`,\n        'INVALID_OPERATION_TYPE'\n      );\n    }\n\n    if (operation.type === 'transfer') {\n      if (!operation.amount) {\n        throw new AuthorizationError('Transfer amount is required', 'MISSING_TRANSFER_AMOUNT');\n      }\n\n      if (!operation.recipient) {\n        throw new AuthorizationError('Transfer recipient is required', 'MISSING_TRANSFER_RECIPIENT');\n      }\n\n      try {\n        new PublicKey(operation.recipient);\n      } catch (error) {\n        throw new AuthorizationError('Invalid transfer recipient address', 'INVALID_TRANSFER_RECIPIENT');\n      }\n\n      if (operation.token) {\n        try {\n          new PublicKey(operation.token);\n        } catch (error) {\n          throw new AuthorizationError('Invalid token address', 'INVALID_TOKEN_ADDRESS');\n        }\n      }\n    }\n  }\n\n  static isValidPublicKey(publicKey: any): boolean {\n    try {\n      new PublicKey(publicKey);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  static isValidEmail(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  static sanitizeConfig(config: any): any {\n    const sanitized = { ...config };\n    \n    // Remove sensitive fields from logs\n    if (sanitized.privateKey) {\n      sanitized.privateKey = '***REDACTED***';\n    }\n    if (sanitized.mnemonic) {\n      sanitized.mnemonic = '***REDACTED***';\n    }\n    if (sanitized.clientSecret) {\n      sanitized.clientSecret = '***REDACTED***';\n    }\n    \n    return sanitized;\n  }\n}","import canonicalize from 'canonicalize';\n// import { cryptoAdapter } from './crypto-adapter';\nimport { Buffer } from 'buffer';\nimport { p256 } from '@noble/curves/p256';\n  import { hmac } from '@noble/hashes/hmac';\n  import { chacha20poly1305 } from '@noble/ciphers/chacha';\nimport { sha256 } from '@noble/hashes/sha256';\n\n\nconst SUITE_ID = new Uint8Array([/* \"HPKE\" */72,80,75,69, /* kem */0,16, /* kdf */0,1, /* aead */0,3]);\nconst HASH_LEN = sha256.outputLen;\n\nconst KEM_ID   = 0x0010; // DHKEM(P-256, HKDF-SHA256)\nconst KDF_ID   = 0x0001; // HKDF-SHA256\nconst AEAD_ID  = 0x0003; // ChaCha20-Poly1305\n\nfunction i2osp2(n: number) {\n  const b = new Uint8Array(2);\n  b[0] = (n >>> 8) & 0xff; b[1] = n & 0xff;\n  return b;\n}\n\nconst KEM_SUITE_ID   = concat(\n  new TextEncoder().encode('KEM'),\n  i2osp2(KEM_ID)\n);\n\nconst HPKE_SUITE_ID  = concat(\n  new TextEncoder().encode('HPKE'),\n  i2osp2(KEM_ID),\n  i2osp2(KDF_ID),\n  i2osp2(AEAD_ID)\n);\n\n\nfunction concat(...arrs: Uint8Array[]) {\n  const len = arrs.reduce((s,a)=>s+a.length,0);\n  const out = new Uint8Array(len);\n  let off = 0;\n  for (const a of arrs) { out.set(a, off); off += a.length; }\n  return out;\n}\n\n// HKDF-Extract(salt, ikm) = HMAC-Hash(salt || zeros, ikm)\nfunction hkdfExtract(salt: Uint8Array, ikm: Uint8Array) {\n  const _salt = (salt && salt.length) ? salt : new Uint8Array(sha256.outputLen);\n  return hmac(sha256, _salt, ikm); // PRK (HashLen bytes)\n}\n\nfunction hkdfExpand(prk: Uint8Array, info: Uint8Array, L: number) {\n  const n = Math.ceil(L / HASH_LEN);\n  if (n > 255) throw new Error('hkdfExpand: L too large');\n  let t: Uint8Array = new Uint8Array(0);\n  const okm = new Uint8Array(L);\n  let off = 0;\n\n  for (let i = 1; i <= n; i++) {\n    const input = new Uint8Array(t.length + info.length + 1);\n    input.set(t, 0);\n    input.set(info, t.length);\n    input[input.length - 1] = i;\n    t = hmac(sha256, prk, new Uint8Array(Buffer.from(input))) as Uint8Array;       // T(i) = HMAC(PRK, T(i-1) || info || i)\n    const copy = i < n ? HASH_LEN : (L - off);\n    okm.set(t.subarray(0, copy), off);\n    off += copy;\n  }\n  return okm;\n}\n\n/**\n * Extracts the raw private key from a PKCS#8 DER-encoded private key\n * For P-256 ECDSA keys, the raw private key is 32 bytes\n */\nfunction extractRawPrivateKeyFromPKCS8(pkcs8Buffer: ArrayBuffer): ArrayBuffer {\n  const bytes = new Uint8Array(pkcs8Buffer);\n\n  // PKCS#8 private key structure for P-256:\n  // The raw 32-byte private key is typically located near the end\n  // Look for the 32-byte private key value after the OID sequences\n\n  // For P-256, look for a 32-byte sequence that represents the private key\n  // It's usually preceded by an OCTET STRING tag (0x04) and length (0x20 = 32)\n  for (let i = 0; i < bytes.length - 33; i++) {\n    if (bytes[i] === 0x04 && bytes[i + 1] === 0x20) {\n      // Found OCTET STRING with length 32 - this should be our private key\n      const rawKey = bytes.slice(i + 2, i + 34);\n      if (rawKey.length === 32) {\n        return rawKey.buffer.slice(rawKey.byteOffset, rawKey.byteOffset + rawKey.byteLength);\n      }\n    }\n  }\n\n  throw new Error('Could not extract raw private key from PKCS#8 format');\n}\n\n// RFC 9180 §4: LabeledExtract\nfunction labeledExtract(salt: Uint8Array, suiteId: Uint8Array, label: string, ikm: Uint8Array) {\n  const labeledIKM = concat(\n    new TextEncoder().encode('HPKE-v1'),\n    suiteId,\n    new TextEncoder().encode(label),\n    ikm\n  );\n  return hkdfExtract(salt, labeledIKM); // returns PRK\n}\n\n// RFC 9180 §4: LabeledExpand\nfunction labeledExpand(prk: Uint8Array, suiteId: Uint8Array, label: string, info: Uint8Array, L: number) {\n  const labeledInfo = concat(\n    i2osp2(L),\n    new TextEncoder().encode('HPKE-v1'),\n    suiteId,\n    new TextEncoder().encode(label),\n    info\n  );\n  return hkdfExpand(prk, labeledInfo, L);   // ✅ Expand-only\n}\n\nexport async function decryptAuthorizationKey(\n  encryptedAuthKey: { encapsulated_key: string; ciphertext: string },\n  recipientPrivateKey: string\n): Promise<string> {\n  // Try the working HPKE implementation without WebCrypto\n  try {\n\n    const pkcs8Buffer2 = base64ToBuffer(recipientPrivateKey);\n    const rawPrivateKey2 = extractRawPrivateKeyFromPKCS8(pkcs8Buffer2);\n\n    // // 2. Perform ECDH key agreement\n    const encapsulatedPublicKey = base64ToBuffer(encryptedAuthKey.encapsulated_key);\n\n    const sharedSecretFull = p256.getSharedSecret(new Uint8Array(rawPrivateKey2), new Uint8Array(encapsulatedPublicKey));\n\n    // 1) Extract x-coordinate (zz) - remove compression byte\n    const dhZz = sharedSecretFull.slice(1); // 32B x-coordinate, drop 0x03 compression byte\n\n    // 2) Generate recipient public key (uncompressed)\n    const pkRm = p256.getPublicKey(new Uint8Array(rawPrivateKey2), false); // 65B uncompressed, starts with 0x04\n    const pkRmCompressed = p256.getPublicKey(new Uint8Array(rawPrivateKey2), true); // 0x02/0x03...\n\n    // 3) Create KEM context = enc || pkRm\n    // const kem_context = concat(new Uint8Array(encapsulatedPublicKey), pkRm);\n    const kem_context = concat(new Uint8Array(encapsulatedPublicKey), pkRmCompressed);\n\n    // 4) DHKEM derivation per RFC 9180 §7.1 (uses KEM_SUITE_ID)\n    const eae_prk = labeledExtract(new Uint8Array(), KEM_SUITE_ID, 'eae_prk', dhZz);\n    const kem_shared_secret = labeledExpand(eae_prk, KEM_SUITE_ID, 'shared_secret', kem_context, sha256.outputLen);\n\n    // HPKE mode (0x00 = Base mode, no PSK, no Auth)\n    const mode = new Uint8Array([0x00]); // base mode\n    const psk = new Uint8Array();        // none\n    const psk_id = new Uint8Array();     // none\n    const info = new Uint8Array();       // none\n\n    // Hash the PSK_ID (empty for base mode) - uses HPKE_SUITE_ID\n    const psk_id_hash = labeledExtract(psk, HPKE_SUITE_ID, 'psk_id_hash', psk_id);\n\n    // Hash the info (empty for basic usage) - uses HPKE_SUITE_ID\n    const info_hash = labeledExtract(new Uint8Array(), HPKE_SUITE_ID, 'info_hash', info);\n\n    // Create key_schedule_context: mode || psk_id_hash || info_hash\n    const key_schedule_context = concat(mode, psk_id_hash, info_hash);\n\n    // Correct: salt = psk (empty), ikm = KEM shared_secret (uses HPKE_SUITE_ID)\n    const secret = labeledExtract(psk, HPKE_SUITE_ID, 'secret', kem_shared_secret);\n\n    // LabeledExpand to get key, base_nonce, and exporter_secret (uses HPKE_SUITE_ID)\n    const derivedKey = labeledExpand(secret, HPKE_SUITE_ID, 'key', key_schedule_context, 32);\n    const baseNonce = labeledExpand(secret, HPKE_SUITE_ID, 'base_nonce', key_schedule_context, 12);\n\n    // 4. Decrypt using ChaCha20Poly1305 with derived baseNonce\n    const ciphertext = base64ToBuffer(encryptedAuthKey.ciphertext);\n    const encryptedData = new Uint8Array(ciphertext); // Entire ciphertext (no nonce prepended in HPKE)\n\n    const aead = chacha20poly1305(derivedKey, baseNonce);\n    const decryptedBytes2 = aead.decrypt(encryptedData);\n\n    return new TextDecoder().decode(decryptedBytes2);\n\n\n  } catch (error) {\n    console.error('WebCrypto HPKE decryption failed:', error);\n    throw error;\n  }\n}\n\nfunction createPKCS8PrivateKey(privateKeyBytes: Uint8Array): Uint8Array {\n      // Simplified PKCS#8 format for P-256 private key\n      // For now, just wrap the private key bytes (can be enhanced later)\n      const header = new Uint8Array([\n        0x30, 0x81, 0x87, // SEQUENCE, length varies\n        0x02, 0x01, 0x00, // INTEGER version = 0\n        0x30, 0x13, // SEQUENCE algorithm identifier\n        0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, // OID: ecPublicKey\n        0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07, // OID: prime256v1\n        0x04, 0x6d // OCTET STRING\n      ]);\n      \n      // ECPrivateKey structure\n      const ecPrivateKey = new Uint8Array([\n        0x30, 0x6b, // SEQUENCE\n        0x02, 0x01, 0x01, // INTEGER version = 1\n        0x04, 0x20, // OCTET STRING, 32 bytes\n        ...privateKeyBytes\n      ]);\n      \n      const result = new Uint8Array(header.length + ecPrivateKey.length);\n      result.set(header);\n      result.set(ecPrivateKey, header.length);\n      \n      return result;\n    }\n\nfunction createSPKIPublicKey(publicKeyBytes: Uint8Array): Uint8Array {\n    // SPKI format for P-256 public key\n    // SubjectPublicKeyInfo ::= SEQUENCE {\n    //   algorithm         AlgorithmIdentifier,\n    //   subjectPublicKey  BIT STRING }\n    \n    // P-256 algorithm identifier OID: 1.2.840.10045.2.1 (ecPublicKey) + 1.2.840.10045.3.1.7 (prime256v1)\n    const algorithmId = new Uint8Array([\n      0x30, 0x13, // SEQUENCE, length 19\n      0x06, 0x07, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x02, 0x01, // OID: ecPublicKey\n      0x06, 0x08, 0x2a, 0x86, 0x48, 0xce, 0x3d, 0x03, 0x01, 0x07 // OID: prime256v1\n    ]);\n    \n    // BIT STRING wrapper for public key\n    const bitStringHeader = new Uint8Array([0x03, publicKeyBytes.length + 1, 0x00]);\n    \n    // Complete SPKI structure\n    const totalLength = algorithmId.length + bitStringHeader.length + publicKeyBytes.length;\n    const spki = new Uint8Array(2 + totalLength);\n    \n    spki[0] = 0x30; // SEQUENCE\n    spki[1] = totalLength; // length\n    spki.set(algorithmId, 2);\n    spki.set(bitStringHeader, 2 + algorithmId.length);\n    spki.set(publicKeyBytes, 2 + algorithmId.length + bitStringHeader.length);\n    \n    return spki;\n  }\n\nexport async function generateHPKEKeyPair() {\n  // Use crypto adapter for cross-platform key generation\n  // const keyPair = await cryptoAdapter.generateKeyPair();\n  const privateKeyBytes = p256.utils.randomPrivateKey();\n  const publicKeyBytes = p256.getPublicKey(privateKeyBytes);\n  \n  // Manually construct SPKI format for P-256 public key\n  const spkiPublicKey = createSPKIPublicKey(publicKeyBytes);\n  const pkcs8PrivateKey = createPKCS8PrivateKey(privateKeyBytes);\n  \n  return {\n    publicKey: Buffer.from(spkiPublicKey).toString('base64'),\n    privateKey: Buffer.from(pkcs8PrivateKey).toString('base64')\n  };\n  \n}\n\n// Helper function to convert base64 to ArrayBuffer\nexport function base64ToBuffer(base64: string): ArrayBuffer {\n  const buffer = Buffer.from(base64, 'base64');\n  return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);\n}\n\n// Helper function to convert base64 to PEM format\nexport function toPem(b64: string, label = 'PRIVATE KEY'): string {\n  return `-----BEGIN ${label}-----\\n${b64.replace(/\\s+/g, '').match(/.{1,64}/g)!.join('\\n')}\\n-----END ${label}-----\\n`;\n}\n\n// Helper function to extract raw private key from PKCS#8 DER\nfunction extractPrivateKeyFromDER(derBytes: Buffer): Uint8Array {\n  // Simple DER parsing to extract 32-byte private key\n  // Look for the 32-byte private key in the DER structure\n  for (let i = 0; i < derBytes.length - 33; i++) {\n    if (derBytes[i] === 0x04 && derBytes[i + 1] === 0x20) {\n      return derBytes.slice(i + 2, i + 34);\n    }\n  }\n  throw new Error('Could not extract private key from DER format');\n}\n\n// Sign payload with authorization key\nexport function signPayload(payload: string, authorizationKey: string): string {\n  // Parse the KMS payload\n  const decodedKmsPayload = Buffer.from(payload, 'base64').toString('utf8');\n  const signaturePayload = JSON.parse(decodedKmsPayload);\n\n  // Canonicalize and convert to buffer\n  const serializedPayload = canonicalize(signaturePayload) as string;\n  const serializedPayloadBuffer = Buffer.from(serializedPayload);\n\n  // Extract raw private key bytes\n  let privateKeyBytes: Uint8Array;\n  if (authorizationKey.includes('BEGIN PRIVATE KEY')) {\n    // Already in PEM format - extract raw key\n    const base64Key = authorizationKey.replace(/-----BEGIN PRIVATE KEY-----|\\-----END PRIVATE KEY-----|\\s/g, '');\n    const derBytes = Buffer.from(base64Key, 'base64');\n    privateKeyBytes = extractPrivateKeyFromDER(derBytes);\n  } else {\n    // Assume it's base64 PKCS#8 DER format\n    const derBytes = Buffer.from(authorizationKey, 'base64');\n    privateKeyBytes = extractPrivateKeyFromDER(derBytes);\n  }\n\n  // Hash the payload with SHA256\n  const hash = sha256(serializedPayloadBuffer);\n\n  // Sign with P-256 ECDSA\n  const signature = p256.sign(hash, privateKeyBytes);\n\n  // Return DER-encoded signature as base64\n  const derSignature = signature.toDERRawBytes();\n  return Buffer.from(derSignature).toString('base64');\n}","import { Keypair } from '@solana/web3.js';\n\nexport interface SolanaKeyPair extends Keypair {}\n\nexport const generateSolanaKeyPair = async (): Promise<SolanaKeyPair> => {\n  try {\n    const keypair = Keypair.generate();\n    \n    return keypair;\n  } catch (error) {\n    throw new Error(`Failed to generate Solana key pair: ${error}`);\n  }\n};\n\nexport const createKeypairFromPrivateKey = (privateKey: string): Keypair => {\n  try {\n    const secretKey = Buffer.from(privateKey, 'base64');\n    return Keypair.fromSecretKey(secretKey);\n  } catch (error) {\n    throw new Error(`Failed to create keypair from private key: ${error}`);\n  }\n};","\n// import { p256 } from \"@noble/curves/p256\";\nimport { createHash } from \"sha256-uint8array\";\nimport { uint8ArrayFromHexString, uint8ArrayToHexString} from '@turnkey/encoding';\n\nexport interface TurnkeyKeyPair {\n  publicKey: string;\n  privateKey: string;\n  publicKeyUncompressed: string;\n}\n\n\nexport const generateTurnkeyKeyPair = async (): Promise<TurnkeyKeyPair> => {\n  \n  try {\n    // Dynamic import to avoid bundling issues\n    const { generateP256KeyPair } = await import('@turnkey/crypto');\n\n    try {\n      const keyPair = generateP256KeyPair();\n      return {\n        publicKey: keyPair.publicKey,\n        privateKey: keyPair.privateKey,\n        publicKeyUncompressed: keyPair.publicKeyUncompressed\n      };\n    } catch (error) {\n      throw new Error(`Failed to generate Turnkey key pair: ${error}`);\n    }\n    \n    \n  } catch (error) {\n    throw new Error(`Failed to generate Turnkey key pair: ${error}`);\n  }\n}; \n\nexport const decryptCredentials = async (credentials: string, privateKey: string): Promise<string> => {\n  try {\n    // Dynamic import to avoid bundling issues\n    const { decryptCredentialBundle } = await import('@turnkey/crypto');\n\n    try {\n      const decryptedData = decryptCredentialBundle(credentials, privateKey);\n      return decryptedData;\n    } catch (error) {\n      throw new Error(`Failed to decrypt credentials: ${error}`);\n    }\n    \n    \n  } catch (error) {\n    throw new Error(`Failed to generate Turnkey key pair: ${error}`);\n  }\n}\n\nexport const getPublicKeyFromDecryptedData = async (data: string): Promise<string> => {\n  const { getPublicKey } = await import('@turnkey/crypto');\n  const publicKey = uint8ArrayToHexString(\n    getPublicKey(uint8ArrayFromHexString(data), true)\n  );  \n  return publicKey;\n}\n\nexport const signWithApiKey = async (input: {\n  payload: string;\n  privateKey: string;\n}): Promise<string> => {\n  const { p256 } = require('@noble/curves/p256');\n  const hash = createHash().update(input.payload).digest();\n  const signature = p256.sign(hash, input.privateKey);\n  return signature.toDERHex();\n};","import { GridApiClient } from '../api/grid-api-client';\nimport {\n  AuthorizationError,\n  InitAuthRequest,\n  InitAuthResponse,\n  CompleteAuthRequest,\n  CompleteAuthResponse,\n  UniversalKeyPair,\n  GridClientUserContext,\n  SessionSecrets,\n  CompleteAuthRequestWithOtp,\n  CompleteAuthAndCreateAccountRequest,\n  ProviderError,\n  SignerProvider,\n  TaggedKeyPair,\n  KeyPairTag\n} from '../types';\nimport { PrivyInitAuthRequest, PrivyCompleteAuthRequest } from '../types/privy';\nimport { TurnkeyInitAuthRequest, TurnkeyCompleteAuthRequest } from '../types/turnkey';\nimport { ValidationUtils } from '../utils/validation';\nimport { generateHPKEKeyPair } from '../utils/crypto/privy-crypto';\nimport { generateSolanaKeyPair } from '../utils/crypto/solana-crypto';\nimport { generateTurnkeyKeyPair } from '../utils/crypto/turnkey-crypto';\n// import { cryptoAdapter } from '../utils/crypto/crypto-adapter';\n\nexport interface AuthenticationRequest {\n  email?: string;\n  keypair?: UniversalKeyPair;\n  passkeyId?: string;\n  provider?: SignerProvider;\n  expiration?: number;\n}\n\nexport interface AuthenticationContext {\n  provider: SignerProvider;\n  sessionId?: string;\n  authPublicKey?: string;\n  email?: string;\n  keypair?: UniversalKeyPair;\n}\n\nexport class AuthenticationManager {\n  private gridApiClient: GridApiClient;\n  private currentContext?: AuthenticationContext;\n\n  constructor(apiClient: GridApiClient) {\n    this.gridApiClient = apiClient;\n  }\n\n  /**\n   * Smart authentication routing based on request type\n   */\n  async authenticate(request: AuthenticationRequest): Promise<InitAuthResponse> {\n    // Determine authentication type\n    const authType = this.determineAuthType(request);\n    \n    switch (authType) {\n      case 'privy':\n      case 'turnkey':\n        return this.initiateEmailAuth(request.email!, authType, request.expiration);\n      \n      case 'solana':\n        return this.validateEOAWallet(request.keypair!);\n      \n      case 'passkey':\n        return this.initiatePasskeyAuth(request.passkeyId!);\n      \n      default:\n        throw new AuthorizationError(\n          `Unsupported authentication type: ${authType}`,\n          'UNSUPPORTED_AUTH_TYPE'\n        );\n    }\n  }\n\n  /**\n   * Complete authentication based on provider type\n   */\n  async complete(request: CompleteAuthRequestWithOtp | CompleteAuthAndCreateAccountRequest): Promise<CompleteAuthResponse> {\n    // Simplified Privy-only implementation for now\n    return this.completePrivyAuth(request);\n  }\n\n  /**\n   * Complete authentication and create account\n   */\n  async completeAndCreateAccount(request: CompleteAuthAndCreateAccountRequest): Promise<any> {\n    // Simplified Privy-only implementation for now\n    return this.completePrivyAuthAndCreateAccount(request);\n  }\n\n  /**\n   * Generate keypairs for all supported providers with appropriate tagging\n   * Returns an array of tagged keypairs for privy (primary), turnkey (backup), solana, and passkey\n   */\n  async generateSessionSecrets(): Promise<SessionSecrets> {\n    const providers: Array<{ type: SignerProvider, tag: KeyPairTag }> = [\n      { type: 'privy', tag: 'primary' },\n      { type: 'turnkey', tag: 'backup' },\n      { type: 'solana', tag: 'solana' },\n      { type: 'passkey', tag: 'passkey' }\n    ];\n\n    const keyPairs: TaggedKeyPair[] = [];\n\n    for (const { type, tag } of providers) {\n      try {\n        const keyPair = await this.generateKeyPair(type);\n        \n        keyPairs.push({\n          publicKey: keyPair.publicKey,\n          privateKey: keyPair.privateKey,\n          provider: type,\n          tag: tag\n        });\n      } catch (error: any) {\n        console.warn(`⚠️ Failed to generate keypair with ${type} provider:`, error.message);\n        // Continue with other providers instead of failing completely\n      }\n    }\n\n    if (keyPairs.length === 0) {\n      throw new ProviderError(\n        'Failed to generate keypairs with any provider. Please check provider configurations.',\n        'privy'\n      );\n    }\n\n    return keyPairs;\n  }\n\n  /**\n   * Generate keypair for specific provider\n   */\n  async generateKeyPair(provider: SignerProvider): Promise<UniversalKeyPair> {\n    switch (provider) {\n      case 'privy':\n        // For now, use HPKE key pair generation\n        const hpkeKeyPair = await generateHPKEKeyPair();\n        return {\n          publicKey: hpkeKeyPair.publicKey,\n          privateKey: hpkeKeyPair.privateKey\n        };\n      \n      case 'turnkey':\n        return generateTurnkeyKeyPair();\n      \n      case 'solana':\n        const solanaKp = await generateSolanaKeyPair();\n        return {\n          publicKey: solanaKp.publicKey.toString(),\n          privateKey: Buffer.from(solanaKp.secretKey).toString('hex')\n        };\n      \n      case 'passkey':\n        const passkeyKp = await generateSolanaKeyPair();\n        return {\n          publicKey: passkeyKp.publicKey.toString(),\n          privateKey: Buffer.from(passkeyKp.secretKey).toString('hex')\n        };\n      \n      default:\n        throw new AuthorizationError(\n          `Keypair generation not supported for provider: ${provider}`,\n          'UNSUPPORTED_PROVIDER'\n        );\n    }\n  }\n\n  // Private methods for each authentication type\n\n  private async initiateEmailAuth(\n    email: string, \n    provider: 'privy' | 'turnkey',\n    expiration?: number\n  ): Promise<InitAuthResponse> {\n    // Validate email\n    if (!ValidationUtils.isValidEmail(email)) {\n      throw new AuthorizationError('Invalid email format', 'INVALID_EMAIL');\n    }\n\n    // Generate auth keypair for the provider\n    const authKeyPair = await this.generateKeyPair(provider);\n\n    // Store context\n    this.currentContext = {\n      provider,\n      email,\n      authPublicKey: authKeyPair.publicKey\n    };\n\n    // Call appropriate API method\n    if (provider === 'privy') {\n      const request: PrivyInitAuthRequest = {\n        email,\n        expiration\n      };\n      const response = await this.gridApiClient.initAuthWithPrivy(request);\n\n      if (!response.success) {\n        throw new ProviderError(\n          response.error || 'Failed to initiate Privy authentication',\n          provider,\n          response.code ? parseInt(response.code) : undefined\n        );\n      }\n      \n      return response.data;\n    } else {\n      const request: TurnkeyInitAuthRequest = {\n        email,\n        expiration\n      };\n      \n      const response = await this.gridApiClient.initAuthWithTurnkey(request);\n      \n      if (!response.success) {\n        throw new ProviderError(\n          response.error || 'Failed to initiate Turnkey authentication',\n          provider,\n          response.code ? parseInt(response.code) : undefined\n        );\n      }\n      \n      return { data: response.data };\n    }\n  }\n\n  private async validateEOAWallet(keypair: UniversalKeyPair): Promise<InitAuthResponse> {\n    // For EOA wallets, we just validate the keypair\n    if (!keypair.publicKey || !keypair.privateKey) {\n      throw new AuthorizationError(\n        'Invalid keypair: missing public or private key',\n        'INVALID_KEYPAIR'\n      );\n    }\n\n    // Store context\n    this.currentContext = {\n      provider: 'solana',\n      keypair\n    };\n\n    // No actual authentication needed for EOA\n    return {\n      data: {\n        authenticated: true,\n        provider: 'solana',\n        publicKey: keypair.publicKey\n      }\n    };\n  }\n\n  private async initiatePasskeyAuth(passkeyId: string): Promise<InitAuthResponse> {\n    throw new AuthorizationError(\n      'Passkey authentication not yet implemented',\n      'NOT_IMPLEMENTED'\n    );\n  }\n\n  private async completePrivyAuth(request: CompleteAuthRequestWithOtp | CompleteAuthAndCreateAccountRequest): Promise<CompleteAuthResponse> {\n    const { otpCode, user, sessionSecrets } = request as CompleteAuthAndCreateAccountRequest;\n    \n    // Extract email from context or user\n    const email = this.currentContext?.email || user.email;\n    if (!email) {\n      throw new AuthorizationError('Email is required for Privy authentication', 'MISSING_EMAIL');\n    }\n\n    // Find privy keypair\n    const privyKeypair = sessionSecrets.find(kp => kp.provider === 'privy');\n    if (!privyKeypair) {\n      throw new AuthorizationError('Privy keypair not found', 'MISSING_KEYPAIR');\n    }\n\n    const privyRequest: PrivyCompleteAuthRequest = {\n      email,\n      otpCode,\n      authPublicKey: privyKeypair.publicKey\n    };\n\n    const response = await this.gridApiClient.completePrivyAuth(privyRequest);\n    \n    if (!response.success) {\n      throw new ProviderError(\n        response.error || 'Failed to complete Privy authentication',\n        'privy',\n        response.code ? parseInt(response.code) : undefined\n      );\n    }\n\n    return response.data;\n  }\n\n  private async completeTurnkeyAuth(request: CompleteAuthRequestWithOtp | CompleteAuthAndCreateAccountRequest): Promise<CompleteAuthResponse> {\n    const { otpCode, user, sessionSecrets } = request as CompleteAuthAndCreateAccountRequest;\n    \n    // Extract email from context or user\n    const email = this.currentContext?.email || user.email;\n    if (!email) {\n      throw new AuthorizationError('Email is required for Turnkey authentication', 'MISSING_EMAIL');\n    }\n\n    // Find turnkey keypair\n    const turnkeyKeypair = sessionSecrets.find(kp => kp.provider === 'turnkey');\n    if (!turnkeyKeypair) {\n      throw new AuthorizationError('Turnkey keypair not found', 'MISSING_KEYPAIR');\n    }\n\n    // TODO: These would need to come from the initAuth response in real implementation\n    const turnkeyRequest: TurnkeyCompleteAuthRequest = {\n      mpcPrimaryId: 'placeholder_primary_id',\n      otpId: 'placeholder_otp_id',\n      otpCode: otpCode,\n      authPublicKey: turnkeyKeypair.publicKey\n    };\n\n    const response = await this.gridApiClient.completeTurnkeyAuth(turnkeyRequest);\n    \n    if (!response.success) {\n      throw new ProviderError(\n        response.error || 'Failed to complete Turnkey authentication',\n        'turnkey',\n        response.code ? parseInt(response.code) : undefined\n      );\n    }\n\n    return response.data;\n  }\n\n  private async completePrivyAuthAndCreateAccount(request: CompleteAuthAndCreateAccountRequest): Promise<any> {\n    const { otpCode, user, sessionSecrets } = request;\n\n    const email = this.currentContext?.email || user.email;\n    if (!email) {\n      throw new AuthorizationError('Email is required', 'MISSING_EMAIL');\n    }\n\n    const privyKeypair = sessionSecrets.find(kp => kp.provider === 'privy');\n    if (!privyKeypair) {\n      throw new AuthorizationError('Privy keypair not found', 'MISSING_KEYPAIR');\n    }\n\n    const privyRequest: PrivyCompleteAuthRequest = {\n      email,\n      otpCode,\n      authPublicKey: privyKeypair.publicKey\n    };\n\n    const response = await this.gridApiClient.completePrivyAuthAndCreateAccount(privyRequest);\n    \n    if (!response.success) {\n      throw new ProviderError(\n        response.error || 'Failed to complete Privy auth and create account',\n        'privy',\n        response.code ? parseInt(response.code) : undefined\n      );\n    }\n\n    return response.data;\n  }\n\n  private async completeTurnkeyAuthAndCreateAccount(request: CompleteAuthAndCreateAccountRequest): Promise<any> {\n    const { otpCode, user, sessionSecrets } = request;\n    \n    const email = this.currentContext?.email || user.email;\n    if (!email) {\n      throw new AuthorizationError('Email is required', 'MISSING_EMAIL');\n    }\n\n    const turnkeyKeypair = sessionSecrets.find(kp => kp.provider === 'turnkey');\n    if (!turnkeyKeypair) {\n      throw new AuthorizationError('Turnkey keypair not found', 'MISSING_KEYPAIR');\n    }\n\n    // TODO: These would need to come from the initAuth response in real implementation\n    const turnkeyRequest: TurnkeyCompleteAuthRequest = {\n      mpcPrimaryId: 'placeholder_primary_id',\n      otpId: 'placeholder_otp_id',\n      otpCode: otpCode,\n      authPublicKey: turnkeyKeypair.publicKey\n    };\n\n    const response = await this.gridApiClient.completeTurnkeyAuthAndCreateAccount(turnkeyRequest);\n    \n    if (!response.success) {\n      throw new ProviderError(\n        response.error || 'Failed to complete Turnkey auth and create account',\n        'turnkey',\n        response.code ? parseInt(response.code) : undefined\n      );\n    }\n\n    return response.data;\n  }\n\n  private determineAuthType(request: AuthenticationRequest): SignerProvider {\n    // Explicit provider\n    if (request.provider) {\n      return request.provider;\n    }\n\n    // Email-based auth (default to privy)\n    if (request.email) {\n      return 'privy';\n    }\n\n    // EOA wallet\n    if (request.keypair) {\n      return 'solana';\n    }\n\n    // Passkey\n    if (request.passkeyId) {\n      return 'passkey';\n    }\n\n    throw new AuthorizationError(\n      'Unable to determine authentication type from request',\n      'AMBIGUOUS_AUTH_REQUEST'\n    );\n  }\n  // Getters for current context\n  getCurrentProvider(): SignerProvider | undefined {\n    return this.currentContext?.provider;\n  }\n\n  getCurrentContext(): AuthenticationContext | undefined {\n    return this.currentContext;\n  }\n\n  clearContext(): void {\n    this.currentContext = undefined;\n  }\n}","import { GridApiConfig } from '../api/grid-api-client';\n\nexport const DEFAULT_CONFIG = {\n  timeout: 10000,\n  retryAttempts: 3\n};\n\nexport function getGridConfig(overrides?: Partial<GridApiConfig>): GridApiConfig {\n\n  const apiKey = overrides?.apiKey;\n\n  if(!apiKey) {\n    throw new Error(\"API key is not set\");\n  }\n\n  return {\n    ...DEFAULT_CONFIG,\n    apiKey,\n    ...overrides,\n    baseUrl: overrides?.baseUrl || \"https://grid.squads.xyz\",\n    environment: overrides?.environment || \"sandbox\",\n    solanaRpcUrl: overrides?.solanaRpcUrl || \"https://api.devnet.solana.com\",\n    timeout: overrides?.timeout || 10000,\n    retryAttempts: overrides?.retryAttempts || 3,\n  };\n}","import { ApiSpendingLimitPeriod, AuthorizationError, SpendingLimitPeriod } from \"../types/common\";\n\nconst gridToProgram: Record<SpendingLimitPeriod, string> = {\n    one_time: \"one_time\",\n    daily: \"day\",\n    weekly: \"week\",\n    monthly: \"month\",\n};\n\nconst programToGrid: Record<ApiSpendingLimitPeriod, SpendingLimitPeriod> = {\n    one_time: \"one_time\",\n    day: \"daily\",\n    week: \"weekly\",\n    month: \"monthly\",\n};\n\nexport function gridToProgramPeriod(period: SpendingLimitPeriod): ApiSpendingLimitPeriod {\n    const mapped = gridToProgram[period];\n    if (!mapped) throw new AuthorizationError(\"Invalid period\", \"INVALID_REQUEST\");\n    return mapped as ApiSpendingLimitPeriod;\n}\n\nexport function programToGridPeriod(period: ApiSpendingLimitPeriod): SpendingLimitPeriod {\n    const mapped = programToGrid[period];\n    if (!mapped) throw new AuthorizationError(\"Invalid period\", \"INVALID_REQUEST\");\n    return mapped;\n}","\nimport { BaseAuthProvider } from '../interfaces/base-provider';\nimport {ProviderConfig, AuthProvider, ProviderError, UniversalKeyPair, InitAuthRequest, InitAuthResponse, SignRequest, CompleteAuthRequest, SpendingLimitRequest, GetPasskeysResponse, AddPasskeyRequest, AddPasskeyQueryParams, AddPasskeyResponse, UpdateAccountRequest, CreateAccountRequest, CreateAccountResponse, GetAccountResponse, GetAccountBalancesQueryParams, GetAccountBalancesResponse, CreatePaymentIntentRequest, CreatePaymentIntentResponse, UpdateSpendingLimitRequest, UseSpendingLimitRequest, RequestKycLinkRequest, RequestKycLinkResponse, GetKycStatusResponse, PrepareArbitraryTransactionRequest, PrepareArbitraryTransactionQueryParams, RemovePasskeyRequest, RemovePasskeyQueryParams, RemovePasskeyResponse, RequestVirtualAccountRequest, RequestVirtualAccountResponse, GetVirtualAccountsQueryParams, GetVirtualAccountsResponse, CreateStandingOrderRequest, CreateStandingOrderResponse, GetStandingOrdersQueryParams, GetStandingOrdersResponse, GetStandingOrderResponse, GridTransactionResponse, PrivySignRequest, SolanaSignRequest, TurnkeySignRequest, ApiSpendingLimitRequest } from '../types';\nimport { GridApiClient, GridEnvironment, ApiResponse } from '../api/grid-api-client';\nimport { getGridConfig } from '../config/default-config';\nimport { TransactionResult } from '../managers/signing-manager';\nimport { gridToProgramPeriod } from '../utils/period-mapper';\nimport { GetTransfersOptions, GetTransfersResponse } from '../types';\n\nexport abstract class AbstractBaseProvider implements BaseAuthProvider {\n  protected initialized: boolean = false;\n  protected gridApiClient?: GridApiClient;\n  \n  // Authentication state tracking\n  protected authState: 'unauthenticated' | 'pending' | 'authenticated' = 'unauthenticated';\n  protected currentSessionId?: string;\n  protected sessionExpiresAt?: Date;\n  \n  constructor(\n    public readonly providerType: AuthProvider,\n    public readonly config: ProviderConfig\n  ) {\n    this.initializeApiClient();\n  }\n\n  private initializeApiClient(): void {\n    // Only initialize API client if we have an API key\n    if (!this.config.apiKey) {\n      // Skip API client initialization - crypto operations will still work\n      return;\n    }\n\n    // Initialize Grid API client\n    try {\n      this.gridApiClient = new GridApiClient(getGridConfig({\n        apiKey: this.config.apiKey,\n        environment: this.config.environment as GridEnvironment\n      }));\n    } catch (error: any) {\n      throw new ProviderError(\n        `Failed to initialize Grid API client: ${error.message}`,\n        this.providerType,\n        undefined,\n        error\n      );\n    }\n  }\n\n  abstract generateUniversalKeyPair(): Promise<UniversalKeyPair>;\n\n  // Authentication interface - all providers must implement\n  abstract initiateAuth(request: InitAuthRequest): Promise<InitAuthResponse>;\n\n  abstract completeAuthAndCreateAccount(request: CompleteAuthRequest): Promise<any>;\n\n  // Optional method for providers that need multi-step authentication\n  abstract completeAuth(verificationData: any): Promise<any>;\n\n  abstract sign(request: SignRequest | PrivySignRequest | SolanaSignRequest | TurnkeySignRequest): Promise<any>;\n\n  // Helper method to create ProviderError with complete details\n  protected createProviderError(\n    message: string,\n    response?: ApiResponse,\n    cause?: Error\n  ): ProviderError {\n    return new ProviderError(\n      message,\n      this.providerType,\n      undefined,\n      cause,\n      response?.details,\n      response?.timestamp,\n      response?.requestId\n    );\n  }\n\n  abstract send(reqest: TransactionResult): Promise<any>;\n\n  abstract signAndSend(request: SignRequest): Promise<any>;\n\n  async createSpendingLimit(smartAccountAddress: string, request: SpendingLimitRequest): Promise<GridTransactionResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for setting spending limits',\n          this.providerType\n        );\n      }\n\n      const requestPayload: ApiSpendingLimitRequest = {\n        amount: request.amount,\n        mint: request.mint,\n        period: gridToProgramPeriod(request.period),\n        transaction_signers: request.transaction_signers,\n        spending_limit_signers: request.spending_limit_signers,\n      };\n\n      // Call the Grid API to set the spending limit\n      const response = await this.gridApiClient.createSpendingLimit(smartAccountAddress, requestPayload);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to set spending limit',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to set spending limit: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async updateSpendingLimit(accountAddress: string, spendingLimitAddress: string, request: UpdateSpendingLimitRequest): Promise<GridTransactionResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for updating spending limit',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to update spending limit\n      const response = await this.gridApiClient.updateSpendingLimit(accountAddress, spendingLimitAddress, request);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to update spending limit',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to update spending limit: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async deleteSpendingLimit(accountAddress: string, spendingLimitAddress: string): Promise<GridTransactionResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for deleting spending limit',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to delete spending limit\n      const response = await this.gridApiClient.deleteSpendingLimit(accountAddress, spendingLimitAddress);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to delete spending limit',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to delete spending limit: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async useSpendingLimit(accountAddress: string, spendingLimitAddress: string, request: UseSpendingLimitRequest): Promise<GridTransactionResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for using spending limit',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to use spending limit\n      const response = await this.gridApiClient.useSpendingLimit(accountAddress, spendingLimitAddress, request);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to use spending limit',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to use spending limit: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async getPasskeys(accountAddress: string): Promise<GetPasskeysResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for getting passkeys',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to get passkeys\n      const response = await this.gridApiClient.getPasskeys(accountAddress);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to get passkeys',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to get passkeys: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async addPasskey(accountAddress: string, request: AddPasskeyRequest, queryParams?: AddPasskeyQueryParams): Promise<AddPasskeyResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for adding passkey',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to add passkey\n      const response = await this.gridApiClient.addPasskey(accountAddress, request, queryParams);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to add passkey',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to add passkey: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async createAccount(request: CreateAccountRequest): Promise<CreateAccountResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for creating account',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to create account\n      const response = await this.gridApiClient.createAccount(request);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to create account',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to create account: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async getAccount(accountAddress: string): Promise<GetAccountResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for getting account',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to get account\n      const response = await this.gridApiClient.getAccount(accountAddress);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to get account',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to get account: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async getAccountBalances(accountAddress: string, queryParams?: GetAccountBalancesQueryParams): Promise<GetAccountBalancesResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for getting account balances',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to get account balances\n      const response = await this.gridApiClient.getAccountBalances(accountAddress, queryParams);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to get account balances',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to get account balances: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async getTransfers(accountAddress: string, options?: GetTransfersOptions): Promise<GetTransfersResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for getting transfers',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to get transfers\n      const response = await this.gridApiClient.getTransfers(accountAddress, options);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to get transfers',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to get transfers: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async updateAccount(accountAddress: string, request: UpdateAccountRequest, admin?: boolean): Promise<GridTransactionResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for updating account',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to update account\n      const response = await this.gridApiClient.updateAccount(accountAddress, request, admin);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to update account',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to update account: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async createPaymentIntent(accountAddress: string, request: CreatePaymentIntentRequest): Promise<CreatePaymentIntentResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for creating payment intent',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to create payment intent\n      const response = await this.gridApiClient.createPaymentIntent(accountAddress, request);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to create payment intent',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to create payment intent: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async requestKycLink(accountAddress: string, request: RequestKycLinkRequest): Promise<RequestKycLinkResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for requesting KYC link',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to request KYC link\n      const response = await this.gridApiClient.requestKycLink(accountAddress, request);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to request KYC link',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to request KYC link: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async getKycStatus(accountAddress: string, kycId: string): Promise<GetKycStatusResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for getting KYC status',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to get KYC status\n      const response = await this.gridApiClient.getKycStatus(accountAddress, kycId);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to get KYC status',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to get KYC status: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n    async prepareArbitraryTransaction(accountAddress: string, request: PrepareArbitraryTransactionRequest, queryParams?: PrepareArbitraryTransactionQueryParams): Promise<GridTransactionResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for preparing arbitrary transaction',\n          this.providerType\n        );\n      }\n\n      const transactionSigners = request.transaction_signers || request.account_signers || [];\n\n      request.transaction_signers = transactionSigners; // Api still uses transaction_signers, can be removed when api supports account_signers\n\n      // Call the Grid API to prepare arbitrary transaction\n      const response = await this.gridApiClient.prepareArbitraryTransaction(accountAddress, request, queryParams);\n      \n      if (!response.success || !response.data) {\n        throw this.createProviderError(\n          response.error || 'Failed to prepare arbitrary transaction',\n          response\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to prepare arbitrary transaction: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async removePasskey(accountAddress: string, passkeyAddress: string, request: RemovePasskeyRequest, queryParams?: RemovePasskeyQueryParams): Promise<RemovePasskeyResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for removing passkey',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to remove passkey\n      const response = await this.gridApiClient.removePasskey(accountAddress, passkeyAddress, request, queryParams);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to remove passkey',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to remove passkey: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async requestVirtualAccount(accountAddress: string, request: RequestVirtualAccountRequest): Promise<RequestVirtualAccountResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for requesting virtual account',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to request virtual account\n      const response = await this.gridApiClient.requestVirtualAccount(accountAddress, request);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to request virtual account',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to request virtual account: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async getVirtualAccounts(accountAddress: string, queryParams?: GetVirtualAccountsQueryParams): Promise<GetVirtualAccountsResponse> {\n    try {\n      // Validate that we have Grid API client\n      if (!this.gridApiClient) {\n        throw new ProviderError(\n          'Grid API client is required for getting virtual accounts',\n          this.providerType\n        );\n      }\n\n      // Call the Grid API to get virtual accounts\n      const response = await this.gridApiClient.getVirtualAccounts(accountAddress, queryParams);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(\n          response.error || 'Failed to get virtual accounts',\n          this.providerType,\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Failed to get virtual accounts: ${error.message}`,\n        this.providerType,\n        undefined,\n        error,\n        error.details\n      );\n    }\n  }\n\n  async createStandingOrder(accountAddress: string, request: CreateStandingOrderRequest): Promise<CreateStandingOrderResponse> {\n    try {\n      if (!this.gridApiClient) {\n        throw new ProviderError('Grid API client is required for standing order creation', this.providerType);\n      }\n\n      const response = await this.gridApiClient.createStandingOrder(accountAddress, request);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(response.error || 'Failed to create standing order', this.providerType);\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) throw error;\n      throw new ProviderError(`Failed to create standing order: ${error.message}`, this.providerType, undefined, error);\n    }\n  }\n\n  async getStandingOrders(accountAddress: string, queryParams?: GetStandingOrdersQueryParams): Promise<GetStandingOrdersResponse> {\n    try {\n      if (!this.gridApiClient) {\n        throw new ProviderError('Grid API client is required for standing orders retrieval', this.providerType);\n      }\n\n      const response = await this.gridApiClient.getStandingOrders(accountAddress, queryParams);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(response.error || 'Failed to get standing orders', this.providerType);\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) throw error;\n      throw new ProviderError(`Failed to get standing orders: ${error.message}`, this.providerType, undefined, error);\n    }\n  }\n\n  async getStandingOrder(accountAddress: string, standingOrderId: string): Promise<GetStandingOrderResponse> {\n    try {\n      if (!this.gridApiClient) {\n        throw new ProviderError('Grid API client is required for standing order retrieval', this.providerType);\n      }\n\n      const response = await this.gridApiClient.getStandingOrder(accountAddress, standingOrderId);\n      \n      if (!response.success || !response.data) {\n        throw new ProviderError(response.error || 'Failed to get standing order', this.providerType);\n      }\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) throw error;\n      throw new ProviderError(`Failed to get standing order: ${error.message}`, this.providerType, undefined, error);\n    }\n  }\n\n  // User data encryption methods (client-side only, no API calls)\n  // async encryptUserData(data: any, encryptionKey: string): Promise<string> {\n  //   try {\n  //     return await encryptUserData(data, encryptionKey);\n  //   } catch (error: any) {\n  //     throw new ProviderError(`Failed to encrypt user data: ${error.message}`, this.providerType, undefined, error);\n  //   }\n  // }\n\n  // async decryptUserData(encryptedData: string, encryptionKey: string): Promise<any> {\n  //   try {\n  //     return await decryptUserData(encryptedData, encryptionKey);\n  //   } catch (error: any) {\n  //     throw new ProviderError(`Failed to decrypt user data: ${error.message}`, this.providerType, undefined, error);\n  //   }\n  // }\n\n  // generateEncryptionKey(): string {\n  //   try {\n  //     return generateEncryptionKey();\n  //   } catch (error: any) {\n  //     throw new ProviderError(`Failed to generate encryption key: ${error.message}`, this.providerType, undefined, error);\n  //   }\n  // }\n}","import { p256 } from \"@noble/curves/p256\";\nimport * as hkdf from \"@noble/hashes/hkdf\";\nimport { sha256 } from \"@noble/hashes/sha256\";\nimport { chacha20poly1305 } from \"@noble/ciphers/chacha\";\nimport { randomBytes } from \"@noble/hashes/utils\";\n\nimport {\n  uint8ArrayToHexString,\n  uint8ArrayFromHexString,\n} from \"@turnkey/encoding\";\n\n// Math functions (from ./math.ts)\n/**\n * Test if a specific bit is set.\n */\nconst testBit = (n: bigint, i: number): boolean => {\n  const m = BigInt(1) << BigInt(i);\n  return (n & m) !== BigInt(0);\n};\n\n/**\n * Compute the modular exponentiation.\n */\nconst modPow = (b: bigint, exp: bigint, p: bigint): bigint => {\n  if (exp === BigInt(0)) {\n    return BigInt(1);\n  }\n  let result = b % p;\n  const exponentBitString = exp.toString(2);\n  for (let i = 1; i < exponentBitString.length; ++i) {\n    result = (result * result) % p;\n    if (exponentBitString[i] === \"1\") {\n      result = (result * b) % p;\n    }\n  }\n  return result;\n};\n\n/**\n * Compute the modular square root using the Tonelli-Shanks algorithm.\n */\nconst modSqrt = (x: bigint, p: bigint): bigint => {\n  if (p <= BigInt(0)) {\n    throw new Error(\"p must be positive\");\n  }\n  const base = x % p;\n\n  // Check if p % 4 == 3 (applies to NIST curves P-256, P-384, and P-521)\n  if (testBit(p, 0) && testBit(p, 1)) {\n    const q = (p + BigInt(1)) >> BigInt(2);\n    const squareRoot = modPow(base, q, p);\n    if ((squareRoot * squareRoot) % p !== base) {\n      throw new Error(\"could not find a modular square root\");\n    }\n    return squareRoot;\n  }\n\n  // Other elliptic curve types not supported\n  throw new Error(\"unsupported modulus value\");\n};\n\n// HPKE Constants (from Turnkey implementation)\nconst HPKE_VERSION = new Uint8Array([72, 80, 75, 69, 45, 118, 49]); // \"HPKE-v1\"\n\n// ChaCha20-Poly1305 specific constants\nconst CHACHA_KEY_INFO = new Uint8Array([\n  0,\n  32, // Length: 32 bytes\n  72,\n  80,\n  75,\n  69,\n  45,\n  118,\n  49, // \"HPKE-v1\"\n  0,\n  16, // KEM ID: DHKEM-P256-HKDF-SHA256 (0x0010)\n  0,\n  1, // KDF ID: HKDF-SHA256 (0x0001)\n  0,\n  3, // AEAD ID: ChaCha20Poly1305 (0x0003)\n  107,\n  101,\n  121, // \"key\"\n]);\n\nconst NONCE_INFO = new Uint8Array([\n  0,\n  12, // Length: 12 bytes\n  72,\n  80,\n  75,\n  69,\n  45,\n  118,\n  49, // \"HPKE-v1\"\n  0,\n  16, // KEM ID: DHKEM-P256-HKDF-SHA256 (0x0010)\n  0,\n  1, // KDF ID: HKDF-SHA256 (0x0001)\n  0,\n  3, // AEAD ID: ChaCha20Poly1305 (0x0003)\n  98,\n  97,\n  115,\n  101,\n  95,\n  110,\n  111,\n  110,\n  99,\n  101, // \"base_nonce\"\n]);\n\n// Suite IDs (from Turnkey implementation)\nconst SUITE_ID_1 = new Uint8Array([\n  75,\n  69,\n  77, // \"KEM\"\n  0,\n  16, // DHKEM-P256-HKDF-SHA256\n]);\n\nconst SUITE_ID_2 = new Uint8Array([\n  72,\n  80,\n  75,\n  69, // \"HPKE\"\n  0,\n  16, // KEM ID: DHKEM-P256-HKDF-SHA256\n  0,\n  1, // KDF ID: HKDF-SHA256\n  0,\n  3, // AEAD ID: ChaCha20Poly1305\n]);\n\n// Labels (from Turnkey implementation)\nconst LABEL_EAE_PRK = new Uint8Array([\n  101,\n  97,\n  101,\n  95,\n  112,\n  114,\n  107, // \"eae_prk\"\n]);\n\nconst LABEL_SHARED_SECRET = new Uint8Array([\n  115,\n  104,\n  97,\n  114,\n  101,\n  100,\n  95,\n  115,\n  101,\n  99,\n  114,\n  101,\n  116, // \"shared_secret\"\n]);\n\nconst LABEL_SECRET = new Uint8Array([\n  115,\n  101,\n  99,\n  114,\n  101,\n  116, // \"secret\"\n]);\n\nconst LABEL_BASE_NONCE = new Uint8Array([\n  98,\n  97,\n  115,\n  101,\n  95,\n  110,\n  111,\n  110,\n  99,\n  101, // \"base_nonce\"\n]);\n\ninterface HpkeDecryptParams {\n  ciphertextBuf: Uint8Array;\n  encappedKeyBuf: Uint8Array;\n  receiverPriv: string;\n}\n\ninterface HpkeEncryptParams {\n  plainTextBuf: Uint8Array;\n  targetKeyBuf: Uint8Array;\n}\n\ninterface HpkeAuthEncryptParams {\n  plainTextBuf: Uint8Array;\n  targetKeyBuf: Uint8Array;\n  senderPriv: string;\n}\n\ninterface KeyPair {\n  privateKey: string;\n  publicKey: string;\n  publicKeyUncompressed: string;\n}\n\n/**\n * Get PublicKey function\n * Derives public key from Uint8Array or hexstring private key\n */\nexport const getPublicKey = (\n  privateKey: Uint8Array | string,\n  isCompressed: boolean = true\n): Uint8Array => {\n  return p256.getPublicKey(privateKey, isCompressed);\n};\n\n/**\n * HPKE Encrypt Function with ChaCha20-Poly1305\n * Based on Turnkey's implementation but using ChaCha20-Poly1305 instead of AES-GCM\n */\nexport const hpkeChachaEncrypt = ({\n  plainTextBuf,\n  targetKeyBuf,\n}: HpkeEncryptParams): Uint8Array => {\n  try {\n    // Standard HPKE Mode (Ephemeral Key Pair)\n    const ephemeralKeyPair = generateP256KeyPair();\n    const senderPrivBuf = uint8ArrayFromHexString(ephemeralKeyPair.privateKey);\n    const senderPubBuf = uint8ArrayFromHexString(\n      ephemeralKeyPair.publicKeyUncompressed\n    );\n\n    const aad = buildAdditionalAssociatedData(senderPubBuf, targetKeyBuf);\n\n    // Step 1: Generate Shared Secret\n    const ss = deriveSS(targetKeyBuf, uint8ArrayToHexString(senderPrivBuf!));\n\n    // Step 2: Generate the KEM context\n    const kemContext = getKemContext(\n      senderPubBuf,\n      uint8ArrayToHexString(targetKeyBuf)\n    );\n\n    // Step 3: Build the HKDF inputs for key derivation\n    let ikm = buildLabeledIkm(LABEL_EAE_PRK, ss, SUITE_ID_1);\n    let info = buildLabeledInfo(\n      LABEL_SHARED_SECRET,\n      kemContext,\n      SUITE_ID_1,\n      32\n    );\n    const sharedSecret = extractAndExpand(new Uint8Array([]), ikm, info, 32);\n\n    // Step 4: Derive the ChaCha20 key\n    ikm = buildLabeledIkm(LABEL_SECRET, new Uint8Array([]), SUITE_ID_2);\n    info = CHACHA_KEY_INFO;\n    const key = extractAndExpand(sharedSecret, ikm, info, 32);\n\n    // Step 5: Derive the nonce\n    info = NONCE_INFO;\n    const nonce = extractAndExpand(sharedSecret, ikm, info, 12);\n\n    // Step 6: Encrypt the data using ChaCha20-Poly1305\n    const encryptedData = chachaEncrypt(plainTextBuf, key, nonce, aad);\n\n    // Step 7: Concatenate the encapsulated key and the encrypted data for output\n    const compressedSenderBuf = compressRawPublicKey(senderPubBuf);\n    const result = new Uint8Array(\n      compressedSenderBuf.length + encryptedData.length\n    );\n    result.set(compressedSenderBuf, 0);\n    result.set(encryptedData, compressedSenderBuf.length);\n\n    return result;\n  } catch (error) {\n    throw new Error(`Unable to perform hpkeChachaEncrypt: ${error}`);\n  }\n};\n\n/**\n * HPKE Authenticated Encrypt Function with ChaCha20-Poly1305\n * Based on Turnkey's implementation but using ChaCha20-Poly1305 instead of AES-GCM\n */\nexport const hpkeChachaAuthEncrypt = ({\n  plainTextBuf,\n  targetKeyBuf,\n  senderPriv,\n}: HpkeAuthEncryptParams): Uint8Array => {\n  try {\n    // Authenticated HPKE Mode\n    const senderPrivBuf = uint8ArrayFromHexString(senderPriv);\n    const senderPubBuf = getPublicKey(senderPriv, false);\n\n    const aad = buildAdditionalAssociatedData(senderPubBuf, targetKeyBuf);\n\n    // Step 1: Generate Shared Secret\n    const ss = deriveSS(targetKeyBuf, uint8ArrayToHexString(senderPrivBuf!));\n\n    // Step 2: Generate the KEM context\n    const kemContext = getKemContext(\n      senderPubBuf,\n      uint8ArrayToHexString(targetKeyBuf)\n    );\n\n    // Step 3: Build the HKDF inputs for key derivation\n    let ikm = buildLabeledIkm(LABEL_EAE_PRK, ss, SUITE_ID_1);\n    let info = buildLabeledInfo(\n      LABEL_SHARED_SECRET,\n      kemContext,\n      SUITE_ID_1,\n      32\n    );\n    const sharedSecret = extractAndExpand(new Uint8Array([]), ikm, info, 32);\n\n    // Step 4: Derive the ChaCha20 key\n    ikm = buildLabeledIkm(LABEL_SECRET, new Uint8Array([]), SUITE_ID_2);\n    info = CHACHA_KEY_INFO;\n    const key = extractAndExpand(sharedSecret, ikm, info, 32);\n\n    // Step 5: Derive the nonce\n    info = NONCE_INFO;\n    const nonce = extractAndExpand(sharedSecret, ikm, info, 12);\n\n    // Step 6: Encrypt the data using ChaCha20-Poly1305\n    const encryptedData = chachaEncrypt(plainTextBuf, key, nonce, aad);\n\n    // Step 7: Concatenate the encapsulated key and the encrypted data for output\n    const compressedSenderBuf = compressRawPublicKey(senderPubBuf);\n    const result = new Uint8Array(\n      compressedSenderBuf.length + encryptedData.length\n    );\n    result.set(compressedSenderBuf, 0);\n    result.set(encryptedData, compressedSenderBuf.length);\n    return result;\n  } catch (error) {\n    throw new Error(`Unable to perform hpkeChachaAuthEncrypt: ${error}`);\n  }\n};\n\n/**\n * HPKE Decrypt Function with ChaCha20-Poly1305\n * Based on Turnkey's implementation but using ChaCha20-Poly1305 instead of AES-GCM\n */\nexport const hpkeChachaDecrypt = async ({\n  ciphertextBuf,\n  encappedKeyBuf,\n  receiverPriv,\n}: HpkeDecryptParams): Promise<Uint8Array> => {\n  try {\n    // Step 1: DHKEM decap - Generate DH shared secret\n    const ss = deriveSS(encappedKeyBuf, receiverPriv);\n\n    // Step 2: Generate KEM context = enc || pkR(serialized)\n    // @hpke/core: kemContext = concat(new Uint8Array(enc), new Uint8Array(pkrm));\n    const receiverPubBuf = getPublicKey(\n      uint8ArrayFromHexString(receiverPriv),\n      false\n    );\n    const kemContext = new Uint8Array(\n      encappedKeyBuf.length + receiverPubBuf.length\n    );\n    kemContext.set(encappedKeyBuf, 0);\n    kemContext.set(receiverPubBuf, encappedKeyBuf.length);\n\n    // Step 3: DHKEM _generateSharedSecret - exact @hpke/core implementation\n    // labeledIkm = kdf.buildLabeledIkm(LABEL_EAE_PRK, dh)\n    const labeledIkm = buildHpkeCoreLabeledIkm(LABEL_EAE_PRK, ss, SUITE_ID_1);\n    // labeledInfo = kdf.buildLabeledInfo(LABEL_SHARED_SECRET, kemContext, secretSize=32)\n    const labeledInfo = buildHpkeCoreLabeledInfo(\n      LABEL_SHARED_SECRET,\n      kemContext,\n      SUITE_ID_1,\n      32\n    );\n    // extractAndExpand(EMPTY.buffer, labeledIkm.buffer, labeledInfo.buffer, secretSize)\n    const kemSharedSecret = extractAndExpand(\n      new Uint8Array([]),\n      labeledIkm,\n      labeledInfo,\n      32\n    );\n    \n    const mode = new Uint8Array([0x00]); // Base mode\n    const psk = new Uint8Array(); // Empty PSK\n    const pskId = new Uint8Array(); // Empty PSK ID\n    const info = new Uint8Array(); // Empty info\n\n    // PSK ID hash using @hpke/core method - labeledExtract, NOT extractAndExpand\n    const pskIdHash = await webCryptoLabeledExtract(\n      new ArrayBuffer(0), // empty salt (EMPTY.buffer)\n      new Uint8Array([112, 115, 107, 95, 105, 100, 95, 104, 97, 115, 104]), // \"psk_id_hash\"\n      pskId,\n      SUITE_ID_2\n    );\n\n    // Info hash using @hpke/core method - labeledExtract, NOT extractAndExpand\n    const infoHash = await webCryptoLabeledExtract(\n      new ArrayBuffer(0), // empty salt (EMPTY.buffer)\n      new Uint8Array([105, 110, 102, 111, 95, 104, 97, 115, 104]), // \"info_hash\"\n      info,\n      SUITE_ID_2\n    );\n\n    // Key schedule context: mode || pskIdHash || infoHash\n    const keyScheduleContext = new Uint8Array(1 + 32 + 32);\n    keyScheduleContext.set(mode, 0);\n    keyScheduleContext.set(new Uint8Array(pskIdHash), 1);\n    keyScheduleContext.set(new Uint8Array(infoHash), 33);\n\n    // Secret labeled IKM\n    const secretLabeledIkm = buildWebCryptoLabeledIkm(\n      LABEL_SECRET,\n      psk, // empty\n      SUITE_ID_2\n    );\n\n    // Derive key using @hpke/core method\n    const keyLabeledInfo = buildWebCryptoLabeledInfo(\n      new Uint8Array([107, 101, 121]), // \"key\"\n      keyScheduleContext,\n      SUITE_ID_2,\n      32\n    );\n    const key = await webCryptoExtractAndExpand(\n      kemSharedSecret.buffer as ArrayBuffer, // salt = KEM shared secret\n      secretLabeledIkm.buffer as ArrayBuffer, // IKM\n      keyLabeledInfo.buffer as ArrayBuffer, // info\n      32\n    );\n\n    // Derive base nonce using @hpke/core method\n    const nonceLabeledInfo = buildWebCryptoLabeledInfo(\n      LABEL_BASE_NONCE,\n      keyScheduleContext,\n      SUITE_ID_2,\n      12\n    );\n    const baseNonce = await webCryptoExtractAndExpand(\n      kemSharedSecret.buffer as ArrayBuffer, // salt = KEM shared secret\n      secretLabeledIkm.buffer as ArrayBuffer, // IKM\n      nonceLabeledInfo.buffer as ArrayBuffer, // info\n      12\n    );\n\n    const decryptedData = chachaDecrypt(\n      ciphertextBuf,\n      new Uint8Array(key),\n      new Uint8Array(baseNonce),\n      undefined\n    );\n    \n    return decryptedData;\n  } catch (error) {\n    throw new Error(`Unable to perform hpkeChachaDecrypt: ${error} `);\n  }\n};\n\n/**\n * React Native compatible decrypt function using ChaCha20-Poly1305\n * Accepts base64 encoded encrypted data and private key\n */\nexport const hpkeChachaDecryptRN = async (\n  encryptedAuthKey: { encapsulated_key: string; ciphertext: string },\n  recipientPrivateKeyBase64: string\n): Promise<Uint8Array> => {\n  try {\n    // Convert base64 to Uint8Array\n    const encappedKeyBuf = base64ToUint8Array(\n      encryptedAuthKey.encapsulated_key\n    );\n    const ciphertextBuf = base64ToUint8Array(encryptedAuthKey.ciphertext);\n\n    // Extract raw private key from PKCS#8 format\n    const pkcs8Buffer = base64ToUint8Array(recipientPrivateKeyBase64);\n    const rawPrivateKey = extractPrivateKeyFromPKCS8Bytes(pkcs8Buffer);\n    const receiverPriv = uint8ArrayToHexString(rawPrivateKey);\n\n    return await hpkeChachaDecrypt({\n      ciphertextBuf,\n      encappedKeyBuf,\n      receiverPriv,\n    });\n  } catch (error) {\n    throw new Error(`React Native HPKE ChaCha decrypt failed: ${error}`);\n  }\n};\n\n/**\n * Generate a P-256 key pair\n */\nexport const generateP256KeyPair = (): KeyPair => {\n  const privateKey = randomBytes(32);\n  const publicKey = getPublicKey(privateKey, true);\n  const publicKeyUncompressed = uint8ArrayToHexString(\n    uncompressRawPublicKey(publicKey)\n  );\n  return {\n    privateKey: uint8ArrayToHexString(privateKey),\n    publicKey: uint8ArrayToHexString(publicKey),\n    publicKeyUncompressed,\n  };\n};\n\n/**\n * Create additional associated data (AAD) for ChaCha20-Poly1305 decryption\n * From Turnkey implementation\n */\nexport const buildAdditionalAssociatedData = (\n  senderPubBuf: Uint8Array,\n  receiverPubBuf: Uint8Array\n): Uint8Array => {\n  return new Uint8Array([\n    ...Array.from(senderPubBuf),\n    ...Array.from(receiverPubBuf),\n  ]);\n};\n\n/**\n * Extract private key from PKCS#8 bytes (from Turnkey implementation)\n */\nexport const extractPrivateKeyFromPKCS8Bytes = (\n  privateKey: Uint8Array\n): Uint8Array => {\n  return privateKey.slice(36, 36 + 32);\n};\n\n/**\n * Compress raw public key (from Turnkey implementation)\n */\nexport const compressRawPublicKey = (rawPublicKey: Uint8Array): Uint8Array => {\n  const len = rawPublicKey.byteLength;\n  var compressedBytes = rawPublicKey.slice(0, (1 + len) >>> 1);\n  compressedBytes[0] = 0x02 | (rawPublicKey[len - 1]! & 0x01);\n  return compressedBytes;\n};\n\n/**\n * Uncompress raw public key (from Turnkey implementation)\n */\nexport const uncompressRawPublicKey = (\n  rawPublicKey: Uint8Array\n): Uint8Array => {\n  if (rawPublicKey.length !== 33) {\n    throw new Error(\"failed to uncompress raw public key: invalid length\");\n  }\n\n  if (!(rawPublicKey[0] === 2 || rawPublicKey[0] === 3)) {\n    throw new Error(\"failed to uncompress raw public key: invalid prefix\");\n  }\n\n  const lsb = rawPublicKey[0] === 3;\n  const x = BigInt(\"0x\" + uint8ArrayToHexString(rawPublicKey.subarray(1)));\n\n  const p = BigInt(\n    \"115792089210356248762697446949407573530086143415290314195533631308867097853951\"\n  );\n  const b = BigInt(\n    \"0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b \"\n  );\n  const a = p - BigInt(3);\n\n  const rhs = ((x * x + a) * x + b) % p;\n  let y = modSqrt(rhs, p);\n  if (lsb !== testBit(y, 0)) {\n    y = (p - y) % p;\n  }\n\n  if (x < BigInt(0) || x >= p) {\n    throw new Error(\"x is out of range\");\n  }\n\n  if (y < BigInt(0) || y >= p) {\n    throw new Error(\"y is out of range\");\n  }\n\n  var uncompressedHexString = \"04\" + bigIntToHex(x, 64) + bigIntToHex(y, 64);\n  return uint8ArrayFromHexString(uncompressedHexString);\n};\n\n// Helper functions (from Turnkey implementation)\n\nconst buildLabeledIkm = (\n  label: Uint8Array,\n  ikm: Uint8Array,\n  suiteId: Uint8Array\n): Uint8Array => {\n  const combinedLength =\n    HPKE_VERSION.length + suiteId.length + label.length + ikm.length;\n  const ret = new Uint8Array(combinedLength);\n  let offset = 0;\n\n  ret.set(HPKE_VERSION, offset);\n  offset += HPKE_VERSION.length;\n\n  ret.set(suiteId, offset);\n  offset += suiteId.length;\n\n  ret.set(label, offset);\n  offset += label.length;\n\n  ret.set(ikm, offset);\n\n  return ret;\n};\n\n// @hpke/core compatible helper functions\nconst buildHpkeCoreLabeledIkm = (\n  label: Uint8Array,\n  ikm: Uint8Array,\n  suiteId: Uint8Array\n): Uint8Array => {\n  // @hpke/core format: \"HPKE-v1\" || suiteId || label || ikm\n  const combinedLength =\n    HPKE_VERSION.length + suiteId.length + label.length + ikm.length;\n  const ret = new Uint8Array(combinedLength);\n  let offset = 0;\n\n  ret.set(HPKE_VERSION, offset);\n  offset += HPKE_VERSION.length;\n\n  ret.set(suiteId, offset);\n  offset += suiteId.length;\n\n  ret.set(label, offset);\n  offset += label.length;\n\n  ret.set(ikm, offset);\n\n  return ret;\n};\n\nconst buildHpkeCoreLabeledInfo = (\n  label: Uint8Array,\n  info: Uint8Array,\n  suiteId: Uint8Array,\n  len: number\n): Uint8Array => {\n  // @hpke/core format: i2osp(len, 2) || \"HPKE-v1\" || suiteId || label || info\n  const ret = new Uint8Array(\n    2 + HPKE_VERSION.length + suiteId.length + label.length + info.length\n  );\n  let offset = 0;\n\n  // i2osp(len, 2) - encode length as 2 bytes big-endian\n  ret.set(new Uint8Array([len >> 8, len & 0xff]), offset);\n  offset += 2;\n\n  ret.set(HPKE_VERSION, offset);\n  offset += HPKE_VERSION.length;\n\n  ret.set(suiteId, offset);\n  offset += suiteId.length;\n\n  ret.set(label, offset);\n  offset += label.length;\n\n  ret.set(info, offset);\n\n  return ret;\n};\n\n// WebCrypto compatible functions matching @hpke/core exactly\nconst buildWebCryptoLabeledIkm = (\n  label: Uint8Array,\n  ikm: Uint8Array,\n  suiteId: Uint8Array\n): Uint8Array => {\n  // @hpke/core format: HPKE_VERSION(7) + suiteId + label + ikm\n  const ret = new Uint8Array(\n    7 + suiteId.byteLength + label.byteLength + ikm.byteLength\n  );\n  ret.set(HPKE_VERSION, 0);\n  ret.set(suiteId, 7);\n  ret.set(label, 7 + suiteId.byteLength);\n  ret.set(ikm, 7 + suiteId.byteLength + label.byteLength);\n  return ret;\n};\n\nconst buildWebCryptoLabeledInfo = (\n  label: Uint8Array,\n  info: Uint8Array,\n  suiteId: Uint8Array,\n  len: number\n): Uint8Array => {\n  // @hpke/core format: i2osp(len, 2) + HPKE_VERSION(7) + suiteId + label + info\n  const ret = new Uint8Array(\n    9 + suiteId.byteLength + label.byteLength + info.byteLength\n  );\n  ret.set(new Uint8Array([0, len]), 0);\n  ret.set(HPKE_VERSION, 2);\n  ret.set(suiteId, 9);\n  ret.set(label, 9 + suiteId.byteLength);\n  ret.set(info, 9 + suiteId.byteLength + label.byteLength);\n  return ret;\n};\n\nconst webCryptoExtractAndExpand = async (\n  salt: ArrayBuffer,\n  ikm: ArrayBuffer,\n  info: ArrayBuffer,\n  len: number\n): Promise<ArrayBuffer> => {\n  // React Native compatible implementation using @noble/hashes HKDF\n  const saltBytes = new Uint8Array(salt);\n  const ikmBytes = new Uint8Array(ikm);\n  const infoBytes = new Uint8Array(info);\n\n  const prk = hkdf.extract(sha256, ikmBytes, saltBytes);\n  const result = hkdf.expand(sha256, prk, infoBytes, len);\n  return (result.buffer as ArrayBuffer).slice(\n    result.byteOffset,\n    result.byteOffset + result.byteLength\n  );\n};\n\n// @hpke/core labeledExtract - only does HKDF-Extract, not Extract+Expand\nconst webCryptoLabeledExtract = async (\n  salt: ArrayBuffer,\n  label: Uint8Array,\n  ikm: Uint8Array,\n  suiteId: Uint8Array\n): Promise<ArrayBuffer> => {\n  const labeledIkm = buildWebCryptoLabeledIkm(label, ikm, suiteId);\n\n  // HKDF-Extract only using @noble/hashes\n  const saltBytes =\n    salt.byteLength === 0 ? new Uint8Array(32) : new Uint8Array(salt); // SHA-256 hash size\n  const result = hkdf.extract(sha256, labeledIkm, saltBytes);\n  return (result.buffer as ArrayBuffer).slice(\n    result.byteOffset,\n    result.byteOffset + result.byteLength\n  );\n};\n\nconst buildLabeledInfo = (\n  label: Uint8Array,\n  info: Uint8Array,\n  suiteId: Uint8Array,\n  len: number\n): Uint8Array => {\n  const suiteIdStartIndex = 9;\n  const ret = new Uint8Array(\n    suiteIdStartIndex + suiteId.byteLength + label.byteLength + info.byteLength\n  );\n  ret.set(new Uint8Array([0, len]), 0);\n  ret.set(HPKE_VERSION, 2);\n  ret.set(suiteId, suiteIdStartIndex);\n  ret.set(label, suiteIdStartIndex + suiteId.byteLength);\n  ret.set(info, suiteIdStartIndex + suiteId.byteLength + label.byteLength);\n  return ret;\n};\n\nconst extractAndExpand = (\n  sharedSecret: Uint8Array,\n  ikm: Uint8Array,\n  info: Uint8Array,\n  len: number\n): Uint8Array => {\n  const prk = hkdf.extract(sha256, ikm, sharedSecret);\n  const resp = hkdf.expand(sha256, prk, info, len);\n  return new Uint8Array(resp);\n};\n\nconst deriveSS = (encappedKeyBuf: Uint8Array, priv: string): Uint8Array => {\n  const ss = p256.getSharedSecret(\n    uint8ArrayFromHexString(priv),\n    encappedKeyBuf\n  );\n  return ss.slice(1);\n};\n\nconst chachaEncrypt = (\n  plainTextData: Uint8Array,\n  key: Uint8Array,\n  nonce: Uint8Array,\n  aad?: Uint8Array\n): Uint8Array => {\n  const chacha = chacha20poly1305(key, nonce, aad);\n  return chacha.encrypt(plainTextData);\n};\n\nconst chachaDecrypt = (\n  encryptedData: Uint8Array,\n  key: Uint8Array,\n  nonce: Uint8Array,\n  aad?: Uint8Array\n): Uint8Array => {\n  const chacha = chacha20poly1305(key, nonce, aad);\n  return chacha.decrypt(encryptedData);\n};\n\nconst getKemContext = (\n  encappedKeyBuf: Uint8Array,\n  publicKey: string\n): Uint8Array => {\n  const encappedKeyArray = new Uint8Array(encappedKeyBuf);\n  const publicKeyArray = uint8ArrayFromHexString(publicKey);\n\n  const kemContext = new Uint8Array(\n    encappedKeyArray.length + publicKeyArray.length\n  );\n  kemContext.set(encappedKeyArray);\n  kemContext.set(publicKeyArray, encappedKeyArray.length);\n\n  return kemContext;\n};\n\nconst bigIntToHex = (num: bigint, length: number): string => {\n  const hexString = num.toString(16);\n  if (hexString.length > length) {\n    throw new Error(\n      `number cannot fit in a hex string of ${length} characters`\n    );\n  }\n  return hexString.padStart(length, \"0\");\n};\n\n// React Native compatible base64 conversion\nconst base64ToUint8Array = (base64: string): Uint8Array => {\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n  return bytes;\n};\n\n/**\n * Format HPKE Buffer Function\n * Returns a JSON string of an encrypted bundle\n */\nexport const formatHpkeBuf = (encryptedBuf: Uint8Array): string => {\n  const compressedSenderBuf = encryptedBuf.slice(0, 33);\n  const encryptedData = encryptedBuf.slice(33);\n\n  const encappedKeyBufHex = uint8ArrayToHexString(\n    uncompressRawPublicKey(compressedSenderBuf)\n  );\n  const ciphertextHex = uint8ArrayToHexString(encryptedData);\n\n  return JSON.stringify({\n    encappedPublic: encappedKeyBufHex,\n    ciphertext: ciphertextHex,\n  });\n};\n","import { AbstractBaseProvider } from \"./base-provider\";\nimport {\n  PrivyConfig,\n  ProviderError,\n  PrivyInitAuthRequest,\n  InitAuthResponse,\n  PrivyCompleteAuthRequest,\n  CompleteAuthResponse,\n  PrivySignRequest,\n  SignRequest,\n  PrivySendRequest,\n  PrivyKeyPair,\n  PrivyInternalSignRequest,\n} from \"../types\";\nimport { generateHPKEKeyPair, signPayload } from \"../utils/crypto/privy-crypto\";\nimport { hpkeChachaDecryptRN } from \"../utils/crypto/hpke-chacha-rn\";\nimport { TransactionResult } from \"../managers/signing-manager\";\n\nexport class PrivyProvider extends AbstractBaseProvider {\n  private privyConfig: PrivyConfig;\n\n  constructor(config: PrivyConfig) {\n    super(\"privy\", config);\n    this.privyConfig = config;\n  }\n\n  async generateLocalKeyPair(): Promise<PrivyKeyPair> {\n    try {\n      const keypair = await generateHPKEKeyPair();\n      return {\n        publicKey: keypair.publicKey,\n        privateKey: keypair.privateKey,\n      };\n    } catch (error: any) {\n      throw new ProviderError(\n        `Failed to generate local Privy key pair: ${error.message}`,\n        \"privy\",\n        undefined,\n        error\n      );\n    }\n  }\n\n  /**\n   * Generate a universal key pair (implements BaseAuthProvider interface)\n   * This automatically uses Privy's P256 key generation for HPKE compatibility\n   */\n  async generateUniversalKeyPair(): Promise<PrivyKeyPair> {\n    const privyKeys = await this.generateLocalKeyPair();\n\n    return {\n      publicKey: privyKeys.publicKey,\n      privateKey: privyKeys.privateKey,\n    };\n  }\n\n  /**\n   * Privy authentication (multi-step process)\n   * Step 1: Initiate authentication with email\n   */\n  async initiateAuth(request: PrivyInitAuthRequest): Promise<InitAuthResponse> {\n    try {\n      // API key is required for authentication operations\n      if (!this.config.apiKey) {\n        throw new ProviderError(\n          \"API key is required for Privy authentication. Provide apiKey in config for API operations.\",\n          \"privy\"\n        );\n      }\n\n      // For Privy, we expect email to be provided\n      if (!request.email) {\n        throw new ProviderError(\n          \"Email is required for Privy authentication\",\n          \"privy\"\n        );\n      }\n\n      // Use Grid API client\n      const client = this.gridApiClient!;\n\n      // Use provider-specific API method\n      const response = await client.initAuthWithPrivy(request);\n\n      if (!response.success) {\n        throw new ProviderError(\n          response.error || \"Privy authentication failed\",\n          \"privy\",\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      const res = response.data;\n      const result = {\n        data: {\n          accountType: res.data.type,\n          email: res.data.email,\n          status: res.data.status,\n          otpSent: res.data.otp_sent,\n          createdAt: res.data.created_at,\n          expiresAt: res.data.expires_at,\n        },\n        metadata: response.data.metadata,\n      };\n      return result;\n    } catch (error) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new ProviderError(\n        `Privy authentication failed: ${errorMessage}`,\n        \"privy\",\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  async initAuth(email: string): Promise<InitAuthResponse> {\n    try {\n      if (!email) {\n        throw new ProviderError(\n          \"Email is required for Privy auth creation\",\n          \"privy\"\n        );\n      }\n      // Use Grid API client to call /auth endpoint (same as your working script)\n      const response = await this.gridApiClient!.initAuthWithPrivy({\n        email: email,\n      });\n\n      if (!response.success) {\n        throw new ProviderError(\n          response.error || \"Failed to create Privy auth\",\n          \"privy\",\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return {\n        ...response.data,\n      };\n    } catch (error) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new ProviderError(\n        `Failed to create Privy auth: ${errorMessage}`,\n        \"privy\",\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  async completeAuthAndCreateAccount(\n    request: PrivyCompleteAuthRequest\n  ): Promise<any> {\n    try {\n      // API key is required for authentication operations\n      if (!this.config.apiKey) {\n        throw new ProviderError(\n          \"API key is required for Privy authentication. Provide apiKey in config for API operations.\",\n          \"privy\"\n        );\n      }\n\n      // Use Grid API client\n      const client = this.gridApiClient!;\n\n      // Use provider-specific API method\n      const response = await client.completePrivyAuthAndCreateAccount(\n        request as PrivyCompleteAuthRequest\n      );\n\n      if (!response.success) {\n        throw new ProviderError(\n          response.error || \"Privy authentication completion failed\",\n          \"privy\",\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new ProviderError(\n        `Privy authentication failed: ${errorMessage}`,\n        \"privy\",\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  /**\n   * Complete Privy authentication with OTP verification\n   */\n  async completeAuth(\n    request: PrivyCompleteAuthRequest\n  ): Promise<CompleteAuthResponse> {\n    try {\n      // API key is required for authentication operations\n      if (!this.config.apiKey) {\n        throw new ProviderError(\n          \"API key is required for Privy authentication. Provide apiKey in config for API operations.\",\n          \"privy\"\n        );\n      }\n\n      // Use Grid API client\n      const client = this.gridApiClient!;\n\n      // Use provider-specific API method\n      const response = await client.completePrivyAuth(request);\n\n      if (!response.success) {\n        throw new ProviderError(\n          response.error || \"Privy authentication completion failed\",\n          \"privy\",\n          response.code ? parseInt(response.code) : undefined,\n          undefined,\n          response.details\n        );\n      }\n\n      return response.data;\n    } catch (error) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new ProviderError(\n        `Privy authentication failed: ${errorMessage}`,\n        \"privy\",\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  async sign(request: PrivyInternalSignRequest): Promise<string> {\n    const { transaction, signers, authorizationKey } = request;\n\n    // Ensure we only have UniversalKeyPairs (Solana Keypairs should be auto-routed away)\n    const firstSigner = signers[0];\n    if (!firstSigner || !(\"privateKey\" in firstSigner)) {\n      throw new ProviderError(\n        \"Privy provider requires UniversalKeyPair format. Solana Keypairs should be auto-routed to Solana provider.\",\n        \"privy\"\n      );\n    }\n\n    // TODO: check if multiple signers would work\n    if (request.signers.length > 1) {\n      throw new ProviderError(\n        \"Privy provider does not support multiple signers\",\n        \"privy\"\n      );\n    }\n\n    try {\n      // Parse the authorization key - it should contain encrypted authorization key info\n\n      // Decrypt the authorization key using ChaCha20-Poly1305 HPKE with WebCrypto\n      const decryptedBytes = await hpkeChachaDecryptRN(\n        authorizationKey,\n        firstSigner.privateKey\n      );\n      const decryptedAuthKey = new TextDecoder().decode(decryptedBytes);\n\n      // Sign the payload\n      const signature = signPayload(transaction, decryptedAuthKey);\n\n      return signature;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n      throw new ProviderError(\n        `Privy signing failed: ${errorMessage}`,\n        \"privy\",\n        undefined,\n        error instanceof Error ? error : undefined\n      );\n    }\n  }\n\n  async send(request: TransactionResult): Promise<any> {\n    // try {\n    // // Type guard to ensure we have the required Privy fields\n    // const privyRequest = request as PrivySendRequest;\n\n    // if (!privyRequest.address || !privyRequest.transaction || !privyRequest.signature) {\n    //   throw new ProviderError(\n    //     'Missing required fields: address, transaction, and signature are required for Privy send',\n    //     'privy'\n    //   );\n    // }\n\n    // const { address, transaction, signature } = privyRequest;\n\n    // const submitPayload = {\n    //   transaction: transaction,\n    //   kms_payloads: [{\n    //       provider: \"privy\",\n    //       signature: signature\n    // }]\n    // };\n\n    // Use the new submitTransaction method with kms_payloads format\n    //   const response = await this.gridApiClient!.submitPrivyTransaction(\n    //     address,\n    //     submitPayload\n    //   );\n\n    //   if (!response.success) {\n    //     throw new ProviderError(\n    //       response.error || 'Transaction submission failed',\n    //       'privy',\n    //       response.code ? parseInt(response.code) : undefined,\n    //       undefined,\n    //       response.details\n    //     );\n    //   }\n\n    //   return response.data;\n    // } catch (error) {\n    //   if (error instanceof ProviderError) {\n    //     throw error;\n    //   }\n    //   throw new ProviderError(\n    //     `Privy send failed: ${error.message}`,\n    //     'privy',\n    //     undefined,\n    //     error,\n    //     error.details\n    //   );\n    // }\n  }\n\n  async signAndSend(_request: SignRequest): Promise<any> {\n    throw new ProviderError(\n      \"Privy provider does not support signing and sending transactions in one step\",\n      \"privy\"\n    );\n  }\n}\n","import { AbstractBaseProvider } from './base-provider';\nimport { TurnkeyConfig, ProviderError, UniversalKeyPair, TurnkeyInitAuthRequest, InitAuthResponse, TurnkeyCompleteAuthRequest, CompleteAuthResponse, TurnkeySignRequest, TurnkeySignResponse, SignRequest, SendTransactionRequest, TurnkeySendRequest, CompleteAuthRequest } from '../types';\nimport { generateTurnkeyKeyPair, type TurnkeyKeyPair, signWithApiKey, decryptCredentials, getPublicKeyFromDecryptedData } from '../utils/crypto/turnkey-crypto';\nimport { TransactionResult } from '../managers/signing-manager';\n\nexport class TurnkeyProvider extends AbstractBaseProvider{\n  private turnkeyConfig: TurnkeyConfig;\n\n  constructor(config: TurnkeyConfig) {\n    super('turnkey', config);\n    this.turnkeyConfig = config;\n  }\n\n  async generateLocalKeyPair(): Promise<TurnkeyKeyPair> {\n    try {\n      const keypair = await generateTurnkeyKeyPair();\n      return keypair;\n    } catch (error: any) {\n      throw new ProviderError(\n        `Failed to generate local Turnkey key pair: ${error.message}`,\n        'turnkey',\n        undefined,\n        error\n      );\n    }\n  }\n\n  /**\n   * Generate a universal key pair (implements BaseAuthProvider interface)\n   * This automatically uses Turnkey's P256 key generation\n   */\n  async generateUniversalKeyPair(): Promise<TurnkeyKeyPair> {\n    const turnkeyKeys = await this.generateLocalKeyPair();\n    \n    return {\n      publicKey: turnkeyKeys.publicKey,\n      privateKey: turnkeyKeys.privateKey,\n      publicKeyUncompressed: turnkeyKeys.publicKeyUncompressed,\n        \n    };\n  }\n\n  /**\n   * Turnkey authentication (multi-step process)\n   * Step 1: Initiate authentication with email and app details\n   */\n  async initiateAuth(request: TurnkeyInitAuthRequest): Promise<InitAuthResponse> {\n\n    try {\n      // API key is required for authentication operations\n      if (!this.config.apiKey) {\n        throw new ProviderError(\n          'API key is required for Turnkey authentication. Provide apiKey in config for API operations.',\n          'turnkey'\n        );\n      }\n\n      // For Turnkey, we expect email to be provided\n      if (!request.email) {\n        throw new ProviderError(\n          'Email is required for Turnkey authentication',\n          'turnkey'\n        );\n      }\n\n      // Use Grid API client\n      const client = this.gridApiClient!;\n\n      // Use provider-specific API method\n      const response = await client.initAuthWithTurnkey(request);\n\n      if (!response.success) {\n        throw new ProviderError(\n          response.error || 'Turnkey authentication failed',\n          'turnkey',\n          response.code ? parseInt(response.code) : undefined\n        );\n      }\n\n      const res = response.data;\n      const result = {\n        data: {\n          mpcPrimaryId: res.data.mpc_primary_id,\n          otpId: res.data.otp_id,\n        },\n        metadata: response.data.metadata\n      }\n      return result;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Turnkey authentication failed: ${error.message}`,\n        'turnkey',\n        undefined,\n        error\n      );\n    }\n  }\n\n  async completeAuthAndCreateAccount(request: CompleteAuthRequest): Promise<any> {\n    throw new ProviderError('Turnkey completeAuthAndCreateAccount not yet implemented', 'turnkey');\n  }\n\n  /**\n   * Complete Turnkey authentication with OTP verification\n   */\n  async completeAuth(request: TurnkeyCompleteAuthRequest): Promise<CompleteAuthResponse> {\n    try {\n      // API key is required for authentication operations\n      if (!this.config.apiKey) {\n        throw new ProviderError(\n          'API key is required for Turnkey authentication. Provide apiKey in config for API operations.',\n          'turnkey'\n        );\n      }\n\n      // Use Grid API client\n      const client = this.gridApiClient!;\n\n      // Use provider-specific API method  \n      const response = await client.completeTurnkeyAuth(request);\n\n      return response.data;\n    } catch (error: any) {\n      if (error instanceof ProviderError) {\n        throw error;\n      }\n      throw new ProviderError(\n        `Turnkey authentication failed: ${error.message}`,\n        'turnkey',\n        undefined,\n        error\n      );\n    }\n  }\n\n  async sign(request: TurnkeySignRequest): Promise<string> {\n    const { transaction, signers, credentials } = request;\n\n    // Ensure we only have UniversalKeyPairs (Solana Keypairs should be auto-routed away)\n    const firstSigner = signers[0];\n    if (!firstSigner || !('privateKey' in firstSigner)) {\n      throw new ProviderError(\n        'Turnkey provider requires UniversalKeyPair format. Solana Keypairs should be auto-routed to Solana provider.',\n        'turnkey'\n      );\n    }\n\n    // TODO: check if multiple signers would work\n    if(request.signers.length > 1) {\n      throw new ProviderError('Turnkey provider does not support multiple signers', 'turnkey');\n    }\n\n    const universalSigner = firstSigner as UniversalKeyPair;\n    const decryptedData = await decryptCredentials(credentials, universalSigner.privateKey);\n    \n    const publicKey = await getPublicKeyFromDecryptedData(decryptedData);\n\n    const signature = await signWithApiKey({\n        payload: JSON.stringify(transaction),\n        privateKey: decryptedData,\n    });\n\n    const stamp = {\n      publicKey,\n      signature,\n    };\n\n\n\n    return JSON.stringify({\n              requestParameters: transaction,\n              stamp,\n          });\n  \n  }\n\n  async send(request: TransactionResult): Promise<any> {\n    try {\n      \n      // const { address, transactionId, payload } = request;\n  \n      // const response = await this.gridApiClient.sendTransaction(address, transactionId, payload);\n  \n      // return response;\n      return {};\n    } catch (error: any) {\n      throw new ProviderError(\n        `Turnkey send failed: ${error.message}`,\n        'turnkey',\n        undefined,\n        error\n      );\n    }\n   \n  }\n\n  async signAndSend(request: SignRequest): Promise<any> {\n    throw new ProviderError('Turnkey provider does not support signing and sending transactions', 'turnkey');\n  }\n\n}","import { GridApiClient } from '../api/grid-api-client';\nimport { Keypair, VersionedTransaction, PublicKey } from '@solana/web3.js';\nimport {\n  AuthorizationError,\n  ProviderError,\n  UniversalKeyPair,\n  TaggedKeyPair,\n  SignerProvider,\n  Session,\n  EncryptedAuthorizationKey,\n  KmsPayload\n\n} from '../types';\nimport { PrivyInternalSignRequest } from '../types/privy';\nimport { TurnkeySignRequest } from '../types/turnkey';\nimport { signPayload } from '../utils/crypto/privy-crypto';\n\n\n// Import local provider classes\nimport { PrivyProvider } from '../providers/privy-provider';\nimport { TurnkeyProvider } from '../providers/turnkey-provider';\nimport { SolanaProvider } from '../providers/solana-provider';\n\nexport interface SignRequest {\n  sessionSecrets: TaggedKeyPair[] | Keypair[];\n  session?: any[];  // Session data from authentication\n  transactionPayload: TransactionPayload;\n}\n\nexport interface SignAndSendRequest {\n  sessionSecrets: TaggedKeyPair[] | Keypair[];\n  session?: any[];  // Session data from authentication\n  transactionPayload: TransactionPayload;\n  address: string;\n}\n\n\nexport interface SignatureResult {\n  provider: SignerProvider;\n  signature: string;\n  publicKey: string;\n  timestamp: number;\n}\n\nexport interface SignResult {\n  signatures: SignatureResult[];\n  payload?: string;\n  aggregatedSignature?: string;\n}\n\nexport interface TransactionPayload {\n  transaction: string;\n  transaction_signers: string[];\n  kms_payloads: KmsPayload[];\n}\n\nenum KmsProvider {\n  PRIVY = 'privy',\n  TURNKEY = 'turnkey'\n}\n\nexport interface KmsSingature {\n  provider: KmsProvider;\n  signature: string;\n}\n\nexport interface TransactionResult {\n  transaction: string;\n  kms_payloads: KmsSingature[];\n}\n\nexport class SigningManager {\n  private gridApiClient: GridApiClient;\n\n  constructor(apiClient: GridApiClient) {\n    this.gridApiClient = apiClient;\n  }\n\n  /**\n   * Get signers that haven't signed the transaction yet\n   */\n  private getUnsignedSigners(transaction: string, requestedSigners: string[]): string[] {\n    try {\n      const transactionBuffer = Buffer.from(transaction, 'base64');\n      const versionedTransaction = VersionedTransaction.deserialize(transactionBuffer);\n\n      const accountKeys = versionedTransaction.message.staticAccountKeys;\n      const signatures = versionedTransaction.signatures;\n\n      console.log(`🔍 Transaction has ${signatures.length} signature slots for ${accountKeys.length} account keys`);\n\n      return requestedSigners.filter(signer => {\n        try {\n          const signerPubkey = new PublicKey(signer);\n          const signerIndex = accountKeys.findIndex(key => key.equals(signerPubkey));\n\n          if (signerIndex === -1) {\n            console.log(`❌ Signer ${signer} not found in transaction account keys`);\n            return false;\n          }\n\n          const signature = signatures[signerIndex];\n\n          // Check if signature is actually present and valid\n          const isValidSignature = signature !== null &&\n                                  signature.length > 0 &&\n                                  !this.isEmptySignature(signature);\n\n          console.log(`🔍 Signer ${signer} at index ${signerIndex}: signature ${isValidSignature ? 'present' : 'missing'}`);\n\n          // Return true if signer needs to sign (signature is missing or empty)\n          return !isValidSignature;\n        } catch (error) {\n          // Invalid public key, skip\n          console.warn(`Invalid public key in signer list: ${signer}`);\n          return false;\n        }\n      });\n    } catch (error) {\n      // If we can't deserialize the transaction, return all signers (fallback behavior)\n      console.warn('Failed to deserialize transaction for signature checking, falling back to all signers');\n      return requestedSigners;\n    }\n  }\n\n  /**\n   * Check if a signature is empty (all zeros or placeholder)\n   */\n  private isEmptySignature(signature: Uint8Array): boolean {\n    // Check if signature is all zeros (64 bytes for Ed25519)\n    if (signature.length !== 64) return true;\n\n    return signature.every(byte => byte === 0);\n  }\n\n  /**\n   * Check if a specific public key has already signed the transaction\n   */\n  private hasPublicKeySigned(transaction: string, pubkey: string): boolean {\n    try {\n      const transactionBuffer = Buffer.from(transaction, 'base64');\n      const versionedTransaction = VersionedTransaction.deserialize(transactionBuffer);\n\n      const accountKeys = versionedTransaction.message.staticAccountKeys;\n      const signatures = versionedTransaction.signatures;\n\n      const signerPubkey = new PublicKey(pubkey);\n      const signerIndex = accountKeys.findIndex(key => key.equals(signerPubkey));\n\n      if (signerIndex === -1) return false;\n\n      const signature = signatures[signerIndex];\n      const isValidSignature = signature !== null &&\n                              signature.length > 0 &&\n                              !this.isEmptySignature(signature);\n\n      return isValidSignature;\n    } catch (error) {\n      return false;\n    }\n  }\n\n  /**\n   * Smart signing with automatic provider selection based on session\n   */\n  async sign(request: SignRequest): Promise<TransactionResult> {\n    // Support both 'payload' and 'transaction' for backward compatibility\n    const transaction = request.transactionPayload.transaction;\n    const transactionSigners = request.transactionPayload.transaction_signers;\n    const kmsPayloads = request.transactionPayload.kms_payloads;\n    const { sessionSecrets, session } = request;\n\n    // Validate inputs\n    if (!transaction && !kmsPayloads) {\n      throw new AuthorizationError('Payload is required for signing', 'MISSING_PAYLOAD');\n    }\n\n    if (!sessionSecrets || sessionSecrets.length === 0) {\n      throw new AuthorizationError('At least one keypair is required for signing', 'NO_KEYPAIRS');\n    }\n\n    const signatures: KmsSingature[] = [];\n    let signedTransaction = transaction;\n\n    // Filter out signers that have already signed the transaction\n    const unsignedSigners = this.getUnsignedSigners(transaction, transactionSigners);\n\n    console.log(`🔍 Signing check: ${transactionSigners.length} total signers, ${unsignedSigners.length} unsigned signers`);\n    if (transactionSigners.length > unsignedSigners.length) {\n      const alreadySigned = transactionSigners.filter(signer => !unsignedSigners.includes(signer));\n      console.log(`✅ Already signed by: ${alreadySigned.join(', ')}`);\n    }\n\n    if (unsignedSigners.length === 0) {\n      console.log('✅ All required signers have already signed the transaction');\n      return {\n        transaction: signedTransaction,\n        kms_payloads: signatures\n      };\n    }\n\n    await Promise.all(unsignedSigners.map(async signer => {\n      \n      if (kmsPayloads && kmsPayloads.length > 0) {\n        const kmsPayload = kmsPayloads.find(kp => kp.address === signer);\n        if (kmsPayload) {\n          switch (kmsPayload.provider) {\n            case 'privy':\n              const keypair = sessionSecrets.find(kp => (kp as TaggedKeyPair).provider === 'privy');\n              const signature = await this.signWithPrivyProvider(kmsPayload.payload, keypair as TaggedKeyPair, session);\n              signatures.push({\n                provider: KmsProvider.PRIVY,\n                signature\n              });\n              break;\n            case 'external':\n              const solanaKeypair = sessionSecrets.find(kp => (kp as Keypair).publicKey.toString() === signer) as Keypair;\n              if (!solanaKeypair) {\n                throw new AuthorizationError(\n                  `No keypair found for external signer: ${signer}`,\n                  'KEYPAIR_NOT_FOUND'\n                );\n              }\n              signedTransaction = await this.signWithSolanaProvider(transaction, solanaKeypair);\n              break;\n            default:\n              throw new AuthorizationError(\n                `Unsupported provider for signing`,\n                'UNSUPPORTED_PROVIDER'\n              );\n              \n          }\n        }\n      } else {\n        const solanaKeypair = sessionSecrets.find(kp => (kp as Keypair).publicKey.toString() === signer) as Keypair;\n        if (!solanaKeypair) {\n          throw new AuthorizationError(\n            `No keypair found for external signer: ${signer}`,\n            'KEYPAIR_NOT_FOUND'\n          );\n        }\n        signedTransaction = await this.signWithSolanaProvider(transaction, solanaKeypair);\n      }\n    }));\n\n    const transactionResult: TransactionResult = {\n      transaction: signedTransaction,\n      kms_payloads: signatures\n    };\n\n    return transactionResult;\n\n    // Auto-detect which keypairs to use based on session and transaction signers\n    // const selectedKeypairs = this.selectKeypairsFromSession(keypairs, session, request.transaction_signers);\n\n    // Execute signing in parallel for all selected keypairs\n    // const signaturePromises = selectedKeypairs.map(keypair => \n    //   this.signWithProvider(payload, keypair, session)\n    // );\n\n    // try {\n    //   const signatures = await Promise.all(signaturePromises);\n      \n    //   // For single signature, return just the signature string for simplicity\n    //   if (signatures.length === 1) {\n    //     return {\n    //       signatures,\n    //       payload: signatures[0].signature\n    //     };\n    //   }\n      \n    //   return {\n    //     signatures,\n    //     payload: typeof payload === 'string' ? payload : JSON.stringify(payload)\n    //   };\n    // } catch (error) {\n    //   if (error instanceof ProviderError || error instanceof AuthorizationError) {\n    //     throw error;\n    //   }\n    //   throw new AuthorizationError(\n    //     `Failed to sign payload: ${error.message}`,\n    //     'SIGNING_FAILED'\n    //   );\n    // }\n  }\n\n  // /**\n  //  * Sign with a specific provider\n  //  */\n  // private async signWithProvider(\n  //   transaction: any,\n  //   keypair: TaggedKeyPair,\n  //   session?: any[]\n  // ): Promise<SignatureResult> {\n  //   const timestamp = Date.now();\n    \n  //   switch (keypair.provider) {\n  //     case 'privy':\n  //       return this.signWithPrivyProvider(transaction, keypair, session);\n      \n  //     case 'turnkey':\n  //       return this.signWithTurnkeyProvider(transaction, keypair);\n      \n  //     case 'solana':\n  //       return this.signWithSolanaProvider(transaction, keypair);\n      \n  //     case 'passkey':\n  //       return this.signWithPasskeyProvider(transaction, keypair);\n      \n  //     default:\n  //       throw new AuthorizationError(\n  //         `Unsupported provider for signing: ${keypair.provider}`,\n  //         'UNSUPPORTED_PROVIDER'\n  //       );\n  //   }\n  // }\n\n  /**\n   * Privy signing implementation using local PrivyProvider\n   */\n  private async signWithPrivyProvider(\n    transaction: any,\n    keypair: TaggedKeyPair,\n    session: any[] | undefined,\n    // timestamp: number\n  ): Promise<string> {\n    // Check if we have session-based signing available\n    if (session && session.length > 0) {\n      // Find Privy session\n      const privySession = session.find(s => s.session?.Privy);\n      if (privySession?.session?.Privy?.session?.encrypted_authorization_key) {\n        // Use encrypted authorization key for signing\n        const authKey = privySession.session.Privy.session.encrypted_authorization_key;\n        const privyRequest: PrivyInternalSignRequest = {\n          transaction: typeof transaction === 'string' ? transaction : JSON.stringify(transaction),\n          sessionSecrets: [keypair],\n          signers: [keypair],\n          authorizationKey: authKey\n        };\n\n        // Use local PrivyProvider for signing\n        const privyProvider = new PrivyProvider({});\n        const signature = await privyProvider.sign(privyRequest);\n        \n        return  signature;\n      }\n    }\n\n    // Fallback to local signing if no session\n    if (!keypair.privateKey) {\n      throw new AuthorizationError(\n        'Private key required for Privy signing without session',\n        'MISSING_PRIVATE_KEY'\n      );\n    }\n\n    // Use direct signing for fallback\n    const signature = signPayload(typeof transaction === 'string' ? transaction : JSON.stringify(transaction), keypair.privateKey);\n    \n    return signature;\n  }\n\n  /**\n   * Turnkey signing implementation using local TurnkeyProvider\n   */\n  private async signWithTurnkeyProvider(\n    transaction: any,\n    keypair: TaggedKeyPair,\n    timestamp: number\n  ): Promise<SignatureResult> {\n    if (!keypair.privateKey) {\n      throw new AuthorizationError(\n        'Private key required for Turnkey signing',\n        'MISSING_PRIVATE_KEY'\n      );\n    }\n\n    const turnkeyRequest: TurnkeySignRequest = {\n      transaction: typeof transaction === 'string' ? transaction : JSON.stringify(transaction),\n      sessionSecrets: [keypair],\n      signers: [keypair],\n      credentials: '' // TODO: Add actual credentials if needed\n    };\n\n    // Use local TurnkeyProvider for signing\n    const turnkeyProvider = new TurnkeyProvider({});\n    const signature = await turnkeyProvider.sign(turnkeyRequest);\n    \n    return {\n      provider: 'turnkey',\n      signature,\n      publicKey: keypair.publicKey,\n      timestamp\n    };\n  }\n\n  /**\n   * Solana signing implementation\n   */\n  private async signWithSolanaProvider(\n    transaction: string,\n    keypair: Keypair\n  ): Promise<string> {\n    try {\n      const transactionBuffer = Buffer.from(transaction, 'base64');\n      const versionedTransaction = VersionedTransaction.deserialize(transactionBuffer);\n      versionedTransaction.sign([keypair]);\n      \n      const serializedTransaction = versionedTransaction.serialize();\n      return Buffer.from(serializedTransaction).toString('base64');\n    } catch (error: any) {\n      throw new AuthorizationError(\n        `Failed to sign with Solana provider: ${error.message}`,\n        'SIGNING_FAILED'\n      );\n    }\n  }\n\n  /**\n   * Passkey signing implementation\n   */\n  private async signWithPasskeyProvider(\n    transaction: any,\n    keypair: TaggedKeyPair,\n    timestamp: number\n  ): Promise<SignatureResult> {\n    throw new AuthorizationError(\n      'Passkey signing not yet implemented',\n      'NOT_IMPLEMENTED'\n    );\n  }\n\n  /**\n   * Select keypairs based on session data\n   * Prioritizes signers by role (primary > backup) and matches addresses with authenticated wallets\n   */\n  private selectKeypairsFromSession(\n    keypairs: TaggedKeyPair[],\n    session?: any[],\n    transaction_signers?: string[]\n  ): TaggedKeyPair[] {\n    \n    // If transaction_signers are provided, use them to determine which providers to use\n    if (transaction_signers && transaction_signers.length > 0 && session && session.length > 0) {\n      return this.selectKeypairsFromTransactionSigners(keypairs, session, transaction_signers);\n    }\n    \n    // If no session, return all keypairs (for non-session based signing like Solana)\n    if (!session || session.length === 0) {\n      // Filter for non-session based providers\n      const nonSessionKeypairs = keypairs.filter(kp => \n        kp.provider === 'solana' || kp.provider === 'passkey'\n      );\n      return nonSessionKeypairs.length > 0 ? nonSessionKeypairs : keypairs;\n    }\n\n    let selected: TaggedKeyPair[] = [];\n\n    // Check each session entry and match with appropriate keypairs\n    for (const sessionEntry of session) {\n      \n      // Check for Privy session\n      if (sessionEntry.provider === 'privy' || sessionEntry.session?.Privy) {\n        const privySession = sessionEntry.session?.Privy;\n        const authenticatedWallets = privySession?.session?.wallets || [];\n        \n        \n        // Find keypairs that match authenticated Privy wallet addresses\n        const matchingPrivyKeypairs = keypairs.filter(kp => {\n          if (kp.provider !== 'privy') return false;\n          \n          // Check if keypair address matches any authenticated wallet address\n          const matchesWallet = authenticatedWallets.some((wallet: any) => \n            wallet.address === kp.publicKey || wallet.public_key === kp.publicKey\n          );\n          \n          return matchesWallet;\n        });\n        \n        // Prioritize by role: primary > backup > others\n        const sortedPrivyKeypairs = matchingPrivyKeypairs.sort((a, b) => {\n          const roleOrder = { primary: 1, backup: 2, solana: 3, passkey: 4 };\n          return (roleOrder[a.tag] || 99) - (roleOrder[b.tag] || 99);\n        });\n        \n        if (sortedPrivyKeypairs.length > 0) {\n          const selectedPrivyKeypair = sortedPrivyKeypairs[0];\n          if (!selected.includes(selectedPrivyKeypair)) {\n            selected.push(selectedPrivyKeypair);\n          }\n        }\n      }\n      \n      // Check for Turnkey session\n      if (sessionEntry.provider === 'turnkey' || sessionEntry.session?.Turnkey) {\n        const turnkeySession = sessionEntry.session?.Turnkey;\n        \n        // For Turnkey, we need to match based on provider and available session data\n        const matchingTurnkeyKeypairs = keypairs.filter(kp => kp.provider === 'turnkey');\n        \n        // Prioritize by role: primary > backup > others\n        const sortedTurnkeyKeypairs = matchingTurnkeyKeypairs.sort((a, b) => {\n          const roleOrder = { primary: 1, backup: 2, solana: 3, passkey: 4 };\n          return (roleOrder[a.tag] || 99) - (roleOrder[b.tag] || 99);\n        });\n        \n        if (sortedTurnkeyKeypairs.length > 0) {\n          const selectedTurnkeyKeypair = sortedTurnkeyKeypairs[0];\n          if (!selected.includes(selectedTurnkeyKeypair)) {\n            selected.push(selectedTurnkeyKeypair);\n          }\n        }\n      }\n      \n      // Check for other providers...\n    }\n\n    // If no session-matched keypairs found, check for EOA wallets\n    if (selected.length === 0) {\n      const eoaKeypairs = keypairs.filter(kp => \n        kp.provider === 'solana' || kp.provider === 'external'\n      );\n      if (eoaKeypairs.length > 0) {\n        selected = eoaKeypairs;\n      }\n    }\n\n    // Default to primary role keypairs if no selection made\n    if (selected.length === 0) {\n      const primaryKeypairs = keypairs.filter(kp => kp.tag === 'primary');\n      selected = primaryKeypairs.length > 0 ? primaryKeypairs : keypairs;\n    }\n\n    return selected;\n  }\n\n  /**\n   * Select keypairs based on transaction_signers addresses\n   * Matches transaction_signers to session wallet addresses to determine providers\n   */\n  private selectKeypairsFromTransactionSigners(\n    keypairs: TaggedKeyPair[],\n    session: any[],\n    transaction_signers: string[]\n  ): TaggedKeyPair[] {\n    const selected: TaggedKeyPair[] = [];\n    \n    // For each required transaction signer\n    for (const signerAddress of transaction_signers) {\n      \n      // Search through all sessions to find which provider has this signer\n      let providerFound: SignerProvider | null = null;\n      \n      for (const sessionEntry of session) {\n        // Check Privy session\n        if (sessionEntry.provider === 'privy' || sessionEntry.session?.Privy) {\n          const privySession = sessionEntry.session?.Privy;\n          const authenticatedWallets = privySession?.session?.wallets || [];\n          \n          const hasThisSigner = authenticatedWallets.some((wallet: any) => \n            wallet.address === signerAddress\n          );\n          \n          if (hasThisSigner) {\n            providerFound = 'privy';\n            break;\n          }\n        }\n        \n      }\n      \n      if (providerFound) {\n        // Find a keypair for this provider\n        const matchingKeypairs = keypairs.filter(kp => kp.provider === providerFound);\n        \n        // Prioritize by role: primary > backup > others\n        const sortedKeypairs = matchingKeypairs.sort((a, b) => {\n          const roleOrder = { primary: 1, backup: 2, solana: 3, passkey: 4 };\n          return (roleOrder[a.tag] || 99) - (roleOrder[b.tag] || 99);\n        });\n        \n        if (sortedKeypairs.length > 0) {\n          const selectedKeypair = sortedKeypairs[0];\n          \n          if (!selected.includes(selectedKeypair)) {\n            selected.push(selectedKeypair);\n          }\n        } else {\n          console.log(`⚠️  No ${providerFound} keypairs available for signer ${signerAddress}`);\n        }\n      } else {\n        console.log(`❌ Could not find provider for signer ${signerAddress}`);\n      }\n    }\n    \n    return selected;\n  }\n\n  /**\n   * Aggregate multiple signatures (for future use)\n   */\n  private aggregateSignatures(signatures: SignatureResult[]): string | undefined {\n    // This would implement signature aggregation logic\n    // For now, return undefined\n    return undefined;\n  }\n}","import { GridClientInterface } from \"../interfaces/sdk-interfaces\";\nimport { GridApiClient, GridApiConfig } from \"../api/grid-api-client\";\nimport {\n  AuthenticationManager,\n  AuthenticationRequest,\n} from \"../managers/authentication-manager\";\nimport {\n  SigningManager,\n  SignRequest,\n  SignResult,\n  TransactionPayload,\n  TransactionResult,\n  SignAndSendRequest,\n} from \"../managers/signing-manager\";\nimport {\n  AuthorizationError,\n  UniversalKeyPair,\n  InitAuthRequest,\n  InitAuthResponse,\n  CompleteAuthResponse,\n  CompleteAuthAndCreateAccountRequest,\n  SendTransactionRequest,\n  SpendingLimitRequest,\n  GetPasskeysResponse,\n  AddPasskeyRequest,\n  AddPasskeyQueryParams,\n  AddPasskeyResponse,\n  UpdateAccountRequest,\n  CreateAccountResponse,\n  GetAccountResponse,\n  GetAccountBalancesQueryParams,\n  GetAccountBalancesResponse,\n  GetTransfersOptions,\n  GetTransfersResponse,\n  CreatePaymentIntentRequest,\n  CreatePaymentIntentResponse,\n  UpdateSpendingLimitRequest,\n  UseSpendingLimitRequest,\n  RequestKycLinkRequest,\n  RequestKycLinkResponse,\n  GetKycStatusResponse,\n  PrepareArbitraryTransactionRequest,\n  PrepareArbitraryTransactionQueryParams,\n  RemovePasskeyRequest,\n  RemovePasskeyQueryParams,\n  RemovePasskeyResponse,\n  RequestVirtualAccountRequest,\n  RequestVirtualAccountResponse,\n  GetVirtualAccountsQueryParams,\n  GetVirtualAccountsResponse,\n  CreateStandingOrderRequest,\n  CreateStandingOrderResponse,\n  GetStandingOrdersQueryParams,\n  GetStandingOrdersResponse,\n  GetStandingOrderResponse,\n  SessionSecrets,\n  CompleteAuthRequestWithOtp,\n  SignerProvider,\n} from \"../types\";\nimport {\n  GridClientContext,\n  GridClientUserContext,\n  CreateAccountInput,\n  CreateAccountRequest,\n  EmailAccountRequest,\n  SignersAccountRequest,\n  AccountPolicies,\n  GridTransactionResponse,\n  ApiSpendingLimitRequest,\n} from \"../types/common\";\nimport { ValidationUtils } from \"../utils/validation\";\nimport { gridToProgramPeriod } from \"../utils/period-mapper\";\nimport { ApiResponse } from \"../api/grid-api-client\";\nimport { VersionedTransaction } from \"@solana/web3.js\";\n\nexport class GridClient implements GridClientInterface {\n  private apiClient: GridApiClient;\n  private authManager: AuthenticationManager;\n  private signingManager: SigningManager;\n  protected apiConfig: GridApiConfig;\n  private solanaRpcUrl?: string;\n\n  // Context management for user and session state\n  private context: GridClientContext;\n\n  // Helper method to create AuthorizationError with complete details\n  private createAuthError(\n    message: string,\n    code: string,\n    response?: ApiResponse\n  ): AuthorizationError {\n    return new AuthorizationError(\n      message,\n      code,\n      undefined,\n      undefined,\n      response?.details,\n      response?.timestamp,\n      response?.requestId\n    );\n  }\n\n  constructor(apiConfig: GridApiConfig) {\n    this.apiConfig = apiConfig;\n    this.apiClient = new GridApiClient(apiConfig);\n    this.authManager = new AuthenticationManager(this.apiClient);\n    this.signingManager = new SigningManager(this.apiClient);\n    this.solanaRpcUrl = apiConfig.solanaRpcUrl;\n\n    // Initialize empty context with signers array\n    this.context = {\n      client: {\n        environment: this.apiConfig.environment,\n        config: this.apiConfig,\n        solanaRpcUrl: this.solanaRpcUrl,\n      },\n      user: {\n        signers: [],\n      },\n    };\n  }\n\n  extractSignableTransaction(transactionData: GridTransactionResponse): VersionedTransaction {\n    const preparedTxBuffer = Buffer.from(transactionData.data!.transaction, 'base64');\n          const preparedTransaction = VersionedTransaction.deserialize(preparedTxBuffer);\n  \n    return preparedTransaction;\n  }\n\n  setExternallySignedTransaction(transactionData: GridTransactionResponse, externallySignedTransaction: VersionedTransaction): GridTransactionResponse {\n    return {\n        data:{\n        transaction: Buffer.from(externallySignedTransaction.serialize()).toString('base64'),\n        transaction_signers: transactionData.data!.transaction_signers,\n        kms_payloads: transactionData.data!.kms_payloads\n      }\n    }\n  }\n  /**\n   * Initialize authentication\n   * Automatically determines the authentication type based on the request\n   */\n  async initAuth(\n    request: InitAuthRequest | AuthenticationRequest\n  ): Promise<InitAuthResponse> {\n    try {\n      // Support both old and new request formats\n      const authRequest: AuthenticationRequest = {\n        email: (request as any).email,\n        keypair: (request as any).keypair,\n        passkeyId: (request as any).passkeyId,\n        provider: (request as any).provider,\n        expiration: (request as any).expiration,\n      };\n\n      const response = await this.authManager.authenticate(authRequest);\n\n      return response;\n    } catch (error: any) {\n      if (error instanceof AuthorizationError) {\n        throw error;\n      }\n      throw new AuthorizationError(\n        `Authentication initialization failed: ${error.message}`,\n        \"AUTH_INIT_FAILED\"\n      );\n    }\n  }\n\n  /**\n   * Complete authentication\n   */\n  async completeAuth(\n    request: CompleteAuthRequestWithOtp\n  ): Promise<CompleteAuthResponse> {\n    try {\n      return await this.authManager.complete(request);\n    } catch (error: any) {\n      if (error instanceof AuthorizationError) {\n        throw error;\n      }\n      throw new AuthorizationError(\n        `Authentication completion failed: ${error.message}`,\n        \"AUTH_COMPLETE_FAILED\"\n      );\n    }\n  }\n\n  /**\n   * Complete authentication and create account\n   */\n  async completeAuthAndCreateAccount(\n    request: CompleteAuthAndCreateAccountRequest\n  ): Promise<any> {\n    try {\n      const result = await this.authManager.completeAndCreateAccount(request);\n\n      // Update context with account info if available\n      if (result?.address) {\n        this.context.user.address = result.address;\n      }\n\n      return result;\n    } catch (error: any) {\n      if (error instanceof AuthorizationError) {\n        throw error;\n      }\n      throw new AuthorizationError(\n        `Account creation failed: ${error.message}`,\n        \"ACCOUNT_CREATE_FAILED\"\n      );\n    }\n  }\n\n  /**\n   * Generate keypairs for all supported providers with appropriate tagging\n   * Returns an array of tagged keypairs for privy (primary), turnkey (backup), solana, and passkey\n   */\n  async generateSessionSecrets(): Promise<SessionSecrets> {\n    return await this.authManager.generateSessionSecrets();\n  }\n\n  /**\n   * Generate keypair for a specific provider\n   */\n  async generateKeyPair(provider?: SignerProvider): Promise<UniversalKeyPair> {\n    // Default to privy if no provider specified\n    const targetProvider = provider || \"privy\";\n    return await this.authManager.generateKeyPair(targetProvider);\n  }\n\n  /**\n   * Sign transaction with automatic provider selection based on session\n   *\n   * @param request - Contains payload, keypairs, and optional session\n   * @returns SignResult with signature(s)\n   */\n  async sign(request: SignRequest): Promise<TransactionResult> {\n    try {\n      const result = await this.signingManager.sign(request);\n      return result;\n    } catch (error: any) {\n      if (error instanceof AuthorizationError) {\n        throw error;\n      }\n      throw new AuthorizationError(\n        `Signing failed: ${error.message}`,\n        \"SIGNING_FAILED\"\n      );\n    }\n  }\n\n  async signAndSend(request: SignAndSendRequest): Promise<any> {\n    try {\n      const signRequest: SignRequest = {\n        sessionSecrets: request.sessionSecrets,\n        transactionPayload: request.transactionPayload,\n        session: request.session,\n      };\n      const transactionResult = await this.signingManager.sign(signRequest);\n      const result = await this.send({\n        address: request.address,\n        signedTransactionPayload: transactionResult,\n      });\n      return result;\n    } catch (error: any) {\n      if (error instanceof AuthorizationError) {\n        throw error;\n      }\n      throw new AuthorizationError(\n        `Signing failed: ${error.message}`,\n        \"SIGNING_FAILED\"\n      );\n    }\n  }\n\n  /**\n   * Send signed transaction to the blockchain\n   */\n  async send(request: SendTransactionRequest): Promise<any> {\n    const { signedTransactionPayload, address } = request;\n    const { transaction, kms_payloads } = signedTransactionPayload;\n\n    // Validate required fields\n    if (!transaction) {\n      throw new AuthorizationError(\n        \"Transaction is required\",\n        \"MISSING_TRANSACTION\"\n      );\n    }\n    if (!address) {\n      throw new AuthorizationError(\"Address is required\", \"MISSING_ADDRESS\");\n    }\n    // if (!signature || !signature.signatures || signature.signatures.length === 0) {\n    //   throw new AuthorizationError('SignResult with signatures is required', 'MISSING_SIGNATURES');\n    // }\n\n    // Create KMS payloads with provider information from SignResult\n    const submitPayload = {\n      transaction,\n      kms_payloads,\n    };\n\n    const response = await this.apiClient.submitTransaction(\n      address,\n      submitPayload\n    );\n\n    if (!response.success || !response.data) {\n      throw this.createAuthError(\n        response.error || \"Transaction submission failed\",\n        \"SUBMIT_FAILED\",\n        response\n      );\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Create account with simplified input\n   */\n  async createAccount(\n    input: CreateAccountInput | CreateAccountRequest\n  ): Promise<CreateAccountResponse> {\n    let request: CreateAccountRequest;\n\n    // Check if it's already a full request\n    if (\"type\" in input) {\n      request = input as CreateAccountRequest;\n    } else {\n      // Convert simplified input to full request\n      request = this.constructAccountPayload(input as CreateAccountInput);\n    }\n\n    const response = await this.apiClient.createAccount(request);\n\n    if (!response.success || !response.data) {\n      throw this.createAuthError(\n        response.error || \"Failed to create account\",\n        \"API_ERROR\",\n        response\n      );\n    }\n\n    // Update context with account info\n    if (response.data.type === \"signers\" && response.data.address) {\n      this.context.user.address = response.data.address;\n    } else if (response.data.type === \"email\" && response.data.email) {\n      // Store email in context for later authentication\n      this.context.user.email = response.data.email;\n    }\n\n    return response.data;\n  }\n\n  /**\n   * Get account information\n   */\n  async getAccount(accountAddress: string): Promise<ApiResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.getAccount(accountAddress);\n    console.log('👀 response', response);\n\n    if (!response.success || !response.data) {\n      return {\n        success: false,\n        error: response.error || \"Failed to get account\"\n      };\n    }\n\n    return response;\n  }\n\n  /**\n   * Update account\n   */\n  async updateAccount(\n    accountAddress: string,\n    request: UpdateAccountRequest,\n    admin?: boolean\n  ): Promise<GridTransactionResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n   const response = await this.apiClient.updateAccount(\n      accountAddress,\n      request,\n      admin\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to update account\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response;\n  }\n\n  /**\n   * Get account balances\n   */\n  async getAccountBalances(\n    accountAddress: string,\n    queryParams?: GetAccountBalancesQueryParams\n  ): Promise<ApiResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.getAccountBalances(\n      accountAddress,\n      queryParams\n    );\n\n    if (!response.success) {\n      return {\n        success: false,\n        error: response.error || \"Failed to get account balances\"\n      };\n    }\n\n    return response;\n  }\n\n  async getTransfers(\n    accountAddress: string,\n    options?: GetTransfersOptions\n  ): Promise<ApiResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.getTransfers(\n      accountAddress,\n      options\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to get transfers\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response;\n  }\n\n  // Spending Limit Methods\n  async createSpendingLimit(\n    smartAccountAddress: string,\n    request: SpendingLimitRequest\n  ): Promise<GridTransactionResponse> {\n    if (!smartAccountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const requestPayload: ApiSpendingLimitRequest = {\n      amount: request.amount,\n      mint: request.mint,\n      period: gridToProgramPeriod(request.period),\n      transaction_signers: request.transaction_signers,\n      spending_limit_signers: request.spending_limit_signers,\n    };\n\n    const response = await this.apiClient.createSpendingLimit(\n      smartAccountAddress,\n      requestPayload\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to set spending limit\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response;\n  }\n\n  async updateSpendingLimit(\n    accountAddress: string,\n    spendingLimitAddress: string,\n    request: UpdateSpendingLimitRequest\n  ): Promise<GridTransactionResponse> {\n    if (!accountAddress || !spendingLimitAddress) {\n      throw new AuthorizationError(\n        \"Account and spending limit addresses are required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.updateSpendingLimit(\n      accountAddress,\n      spendingLimitAddress,\n      request\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to update spending limit\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response;\n  }\n\n  async deleteSpendingLimit(\n    accountAddress: string,\n    spendingLimitAddress: string\n  ): Promise<GridTransactionResponse> {\n    if (!accountAddress || !spendingLimitAddress) {\n      throw new AuthorizationError(\n        \"Account and spending limit addresses are required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.deleteSpendingLimit(\n      accountAddress,\n      spendingLimitAddress\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to delete spending limit\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response;\n  }\n\n  async useSpendingLimit(\n    accountAddress: string,\n    spendingLimitAddress: string,\n    request: UseSpendingLimitRequest\n  ): Promise<GridTransactionResponse> {\n    if (!accountAddress || !spendingLimitAddress) {\n      throw new AuthorizationError(\n        \"Account and spending limit addresses are required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.useSpendingLimit(\n      accountAddress,\n      spendingLimitAddress,\n      request\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to use spending limit\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response;\n  }\n\n  // Passkey Methods\n  async getPasskeys(accountAddress: string): Promise<GetPasskeysResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.getPasskeys(accountAddress);\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to get passkeys\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response.data;\n  }\n\n  async addPasskey(\n    accountAddress: string,\n    request: AddPasskeyRequest,\n    queryParams?: AddPasskeyQueryParams\n  ): Promise<AddPasskeyResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.addPasskey(\n      accountAddress,\n      request,\n      queryParams\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to add passkey\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response.data;\n  }\n\n  async removePasskey(\n    accountAddress: string,\n    passkeyAddress: string,\n    request: RemovePasskeyRequest,\n    queryParams?: RemovePasskeyQueryParams\n  ): Promise<RemovePasskeyResponse> {\n    if (!accountAddress || !passkeyAddress) {\n      throw new AuthorizationError(\n        \"Account and passkey addresses are required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.removePasskey(\n      accountAddress,\n      passkeyAddress,\n      request,\n      queryParams\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to remove passkey\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response.data;\n  }\n\n  // Payment Methods\n  async createPaymentIntent(\n    accountAddress: string,\n    request: CreatePaymentIntentRequest\n  ): Promise<CreatePaymentIntentResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.createPaymentIntent(\n      accountAddress,\n      request\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to create payment intent\",\n        \"API_ERROR\"\n      );\n    }\n\n    // The API response has the actual data nested under response.data.data\n    const apiData = response.data.data || response.data;\n\n    const transactionPayload = {\n      kms_payloads: apiData.kms_payloads,\n      transaction_signers: apiData.transaction_signers,\n      transaction: apiData.transaction,\n    };\n\n    // Return response with excluded fields removed and transaction data wrapped\n    const {\n      kms_payloads,\n      transaction_signers,\n      transaction,\n      ...cleanedResponse\n    } = apiData;\n\n    return {\n      data: {\n        ...cleanedResponse,\n        transactionPayload,\n      },\n    };\n  }\n\n  // KYC Methods\n  async requestKycLink(\n    accountAddress: string,\n    request: RequestKycLinkRequest\n  ): Promise<ApiResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.requestKycLink(\n      accountAddress,\n      request\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to request KYC link\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response;\n  }\n\n  async getKycStatus(\n    accountAddress: string,\n    kycId: string\n  ): Promise<ApiResponse> {\n    if (!accountAddress || !kycId) {\n      throw new AuthorizationError(\n        \"Account address and KYC ID are required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.getKycStatus(accountAddress, kycId);\n\n    if (!response.success) {\n      return {\n        success: false,\n        error: response.error || \"Failed to get KYC status\"\n      };\n    }\n\n    return response;\n  }\n\n  // Transaction Methods\n  async prepareArbitraryTransaction(\n    accountAddress: string,\n    request: PrepareArbitraryTransactionRequest,\n    queryParams?: PrepareArbitraryTransactionQueryParams\n  ): Promise<GridTransactionResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.prepareArbitraryTransaction(\n      accountAddress,\n      request,\n      queryParams\n    );\n\n    if (!response.success || !response.data) {\n      throw this.createAuthError(\n        response.error || \"Failed to prepare arbitrary transaction\",\n        \"API_ERROR\",\n        response\n      );\n    }\n\n    const transactionData = response.data as TransactionPayload;\n\n    if(!transactionData.kms_payloads && !response.data.error) {\n      transactionData.kms_payloads = [];\n    }\n\n    return {\n      data: transactionData,\n    };\n  }\n\n  // Virtual Account Methods\n  async requestVirtualAccount(\n    accountAddress: string,\n    request: RequestVirtualAccountRequest\n  ): Promise<ApiResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.requestVirtualAccount(\n      accountAddress,\n      request\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to request virtual account\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response;\n  }\n\n  async getVirtualAccounts(\n    accountAddress: string,\n    queryParams?: GetVirtualAccountsQueryParams\n  ): Promise<GetVirtualAccountsResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.getVirtualAccounts(\n      accountAddress,\n      queryParams\n    );\n\n    if (!response.success || !response.data) {\n      throw new AuthorizationError(\n        response.error || \"Failed to get virtual accounts\",\n        \"API_ERROR\"\n      );\n    }\n\n    return response.data;\n  }\n\n  // Standing Order Methods\n  async createStandingOrder(\n    accountAddress: string,\n    request: CreateStandingOrderRequest\n  ): Promise<CreateStandingOrderResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.createStandingOrder(\n      accountAddress,\n      request\n    );\n\n    if (!response.success || !response.data) {\n      return {\n        ...response.data,\n        error: response.error,\n      };\n    }\n\n    return response.data;\n  }\n\n  async getStandingOrders(\n    accountAddress: string,\n    queryParams?: GetStandingOrdersQueryParams\n  ): Promise<ApiResponse> {\n    if (!accountAddress) {\n      throw new AuthorizationError(\n        \"Account address is required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.getStandingOrders(\n      accountAddress,\n      queryParams\n    );\n\n    if (!response.success || !response.data) {\n      return {\n        success: false,\n        error: response.error || \"Failed to get standing orders\"\n      };\n    }\n\n    return response;\n  }\n\n  async getStandingOrder(\n    accountAddress: string,\n    standingOrderId: string\n  ): Promise<ApiResponse> {\n    if (!accountAddress || !standingOrderId) {\n      throw new AuthorizationError(\n        \"Account address and standing order ID are required\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    const response = await this.apiClient.getStandingOrder(\n      accountAddress,\n      standingOrderId\n    );\n\n    if (!response.success || !response.data) {\n      return {\n        success: false,\n        error: response.error || \"Failed to get standing order\"\n      };\n    }\n\n    return response;\n  }\n\n  /**\n   * Get current context\n   */\n  getContext(): GridClientContext {\n    return this.context;\n  }\n\n  /**\n   * Update context\n   */\n  updateContext(updates: Partial<GridClientUserContext>): void {\n    this.context.user = {\n      ...this.context.user,\n      ...updates,\n    };\n  }\n\n  /**\n   * Clear authentication context\n   */\n  clearAuthContext(): void {\n    this.authManager.clearContext();\n  }\n\n  /**\n   * Helper to construct account payload from simple input\n   */\n  private constructAccountPayload(\n    input: CreateAccountInput\n  ): CreateAccountRequest {\n    if (!input.email && !input.signer) {\n      throw new AuthorizationError(\n        \"Must provide either email or signer\",\n        \"INVALID_REQUEST\"\n      );\n    }\n\n    if (input.email && input.signer) {\n      throw new AuthorizationError(\n        \"Cannot provide both email and signer\",\n        \"AMBIGUOUS_REQUEST\"\n      );\n    }\n\n    if (input.email) {\n      if (!ValidationUtils.isValidEmail(input.email)) {\n        throw new AuthorizationError(\"Invalid email format\", \"INVALID_EMAIL\");\n      }\n\n      return {\n        type: \"email\",\n        email: input.email,\n      } as EmailAccountRequest;\n    }\n\n    if (input.signer) {\n      if (input.signer.length < 32 || input.signer.length > 44) {\n        throw new AuthorizationError(\n          \"Invalid signer address format\",\n          \"INVALID_REQUEST\"\n        );\n      }\n\n      const accountPolicies: AccountPolicies = {\n        signers: [\n          {\n            address: input.signer,\n            role: \"primary\",\n            permissions: [\"CAN_INITIATE\", \"CAN_EXECUTE\", \"CAN_VOTE\"],\n            provider: \"external\",\n          },\n        ],\n        threshold: 1,\n        time_lock: null,\n        admin_address: null,\n      };\n\n      return {\n        type: \"signers\",\n        policies: accountPolicies,\n        grid_user_id: null,\n        memo: undefined,\n      } as SignersAccountRequest;\n    }\n\n    throw new AuthorizationError(\"Invalid input parameters\", \"INVALID_REQUEST\");\n  }\n}\n"]}