import { Keypair, VersionedTransaction } from '@solana/web3.js';

interface TurnkeyInitAuthRequest extends InitAuthRequest {
    email?: string;
    appName?: string;
    appIconUrl?: string;
}
interface TurnkeyCompleteAuthRequest extends CompleteAuthRequest {
    mpcPrimaryId: string;
    otpId: string;
    otpCode: string;
    authPublicKey: string;
}

interface CreatePasskeySessionRequest {
    action: Action;
    sessionKey: SessionKey;
    env: Env;
    metaInfo: Record<string, any>;
}
interface CreatePasskeySessionResponse {
    url: string;
}
interface SessionKey {
    key: any;
    expiration: number;
}
type Action = 'create' | 'auth' | 'get';

interface PrivyInitAuthRequest extends InitAuthRequest {
    email?: string;
    provider?: string;
}
interface PrivyCompleteAuthRequest extends CompleteAuthRequest {
    email: string;
    otpCode: string;
    authPublicKey: string;
}
interface PrivyInternalSignRequest extends SignRequest {
    signers: UniversalKeyPair[];
    authorizationKey: {
        encapsulated_key: string;
        ciphertext: string;
    };
}

interface ApiResponse<T = any> {
    success: boolean;
    data?: T;
    error?: string;
    code?: string;
    details?: any;
    timestamp?: string;
    requestId?: string;
}
type GridEnvironment = "sandbox" | "production";
interface GridApiConfig {
    apiKey?: string;
    environment: GridEnvironment;
    baseUrl: string;
    timeout?: number;
    retryAttempts?: number;
    solanaRpcUrl?: string;
}
declare class GridApiClient {
    private environment;
    private config;
    private baseUrl;
    constructor(config: GridApiConfig);
    private generateIdempotencyKey;
    hasApiKey(): boolean;
    private requiresApiKey;
    protected request<T>(endpoint: string, options?: {
        method?: "GET" | "POST" | "PUT" | "DELETE" | "PATCH";
        data?: any;
        headers?: Record<string, string>;
    }): Promise<ApiResponse<T>>;
    createPasskeySession(params: CreatePasskeySessionRequest): Promise<ApiResponse<CreatePasskeySessionResponse>>;
    initAuthWithTurnkey(request: TurnkeyInitAuthRequest): Promise<ApiResponse<any>>;
    completeTurnkeyAuth(data: TurnkeyCompleteAuthRequest): Promise<ApiResponse<any>>;
    completeTurnkeyAuthAndCreateAccount(data: TurnkeyCompleteAuthRequest): Promise<ApiResponse<any>>;
    initAuthWithPrivy(request: PrivyInitAuthRequest): Promise<ApiResponse<any>>;
    completePrivyAuthAndCreateAccount(data: PrivyCompleteAuthRequest): Promise<ApiResponse<any>>;
    completePrivyAuth(data: PrivyCompleteAuthRequest): Promise<ApiResponse<any>>;
    sendTransaction(address: string, transactionId: string, payload: ConfirmPayload): Promise<ApiResponse<any>>;
    submitPrivyTransaction(smartAccountAddress: string, submitPayload: any): Promise<ApiResponse<any>>;
    submitTransaction(smartAccountAddress: string, submitPayload: any): Promise<ApiResponse<any>>;
    getAccount(address: string): Promise<ApiResponse<GetAccountResponse>>;
    getTransactions(address: string): Promise<ApiResponse<any>>;
    getAccountBalances(address: string, queryParams?: GetAccountBalancesQueryParams): Promise<ApiResponse<GetAccountBalancesResponse>>;
    getTransfers(address: string, options?: GetTransfersOptions): Promise<ApiResponse<GetTransfersResponse>>;
    getBalance(address: string): Promise<ApiResponse<GetAccountBalancesResponse>>;
    createSpendingLimit(smartAccountAddress: string, request: ApiSpendingLimitRequest): Promise<ApiResponse<GridTransactionResponse>>;
    updateSpendingLimit(accountAddress: string, spendingLimitAddress: string, request: UpdateSpendingLimitRequest): Promise<ApiResponse<GridTransactionResponse>>;
    deleteSpendingLimit(accountAddress: string, spendingLimitAddress: string): Promise<ApiResponse<GridTransactionResponse>>;
    useSpendingLimit(accountAddress: string, spendingLimitAddress: string, request: UseSpendingLimitRequest): Promise<ApiResponse<GridTransactionResponse>>;
    getPasskeys(accountAddress: string): Promise<ApiResponse<GetPasskeysResponse>>;
    addPasskey(accountAddress: string, request: AddPasskeyRequest, queryParams?: AddPasskeyQueryParams): Promise<ApiResponse<AddPasskeyResponse>>;
    removePasskey(accountAddress: string, passkeyAddress: string, request: RemovePasskeyRequest, queryParams?: RemovePasskeyQueryParams): Promise<ApiResponse<RemovePasskeyResponse>>;
    createAccount(request: CreateAccountRequest): Promise<ApiResponse<CreateAccountResponse>>;
    updateAccount(accountAddress: string, request: UpdateAccountRequest, admin?: boolean): Promise<ApiResponse<GridTransactionResponse>>;
    createPaymentIntent(accountAddress: string, request: CreatePaymentIntentRequest): Promise<ApiResponse<CreatePaymentIntentApiResponse>>;
    requestKycLink(accountAddress: string, request: RequestKycLinkRequest): Promise<ApiResponse<RequestKycLinkResponse>>;
    getKycStatus(accountAddress: string, kycId: string): Promise<ApiResponse<GetKycStatusResponse>>;
    prepareArbitraryTransaction(accountAddress: string, request: PrepareArbitraryTransactionRequest, queryParams?: PrepareArbitraryTransactionQueryParams): Promise<ApiResponse<GridTransactionResponse>>;
    requestVirtualAccount(accountAddress: string, request: RequestVirtualAccountRequest): Promise<ApiResponse<RequestVirtualAccountResponse>>;
    getVirtualAccounts(accountAddress: string, queryParams?: GetVirtualAccountsQueryParams): Promise<ApiResponse<GetVirtualAccountsResponse>>;
    createStandingOrder(accountAddress: string, request: CreateStandingOrderRequest): Promise<ApiResponse<CreateStandingOrderResponse>>;
    getStandingOrders(accountAddress: string, queryParams?: GetStandingOrdersQueryParams): Promise<ApiResponse<GetStandingOrdersResponse>>;
    getStandingOrder(accountAddress: string, standingOrderId: string): Promise<ApiResponse<GetStandingOrderResponse>>;
    signWithPrivy(request: PrivyInternalSignRequest): Promise<ApiResponse<{
        signature: string;
    }>>;
    signWithTurnkey(request: any): Promise<ApiResponse<{
        signature: string;
    }>>;
    signWithPasskey(request: any): Promise<ApiResponse<{
        signature: string;
    }>>;
}

interface SignRequest$1 {
    sessionSecrets: TaggedKeyPair[] | Keypair[];
    session?: any[];
    transactionPayload: TransactionPayload;
}
interface SignAndSendRequest {
    sessionSecrets: TaggedKeyPair[] | Keypair[];
    session?: any[];
    transactionPayload: TransactionPayload;
    address: string;
}
interface SignatureResult {
    provider: SignerProvider;
    signature: string;
    publicKey: string;
    timestamp: number;
}
interface SignResult {
    signatures: SignatureResult[];
    payload?: string;
    aggregatedSignature?: string;
}
interface TransactionPayload {
    transaction: string;
    transaction_signers: string[];
    kms_payloads: KmsPayload[];
}
declare enum KmsProvider {
    PRIVY = "privy",
    TURNKEY = "turnkey"
}
interface KmsSingature {
    provider: KmsProvider;
    signature: string;
}
interface TransactionResult {
    transaction: string;
    kms_payloads: KmsSingature[];
}
declare class SigningManager {
    private gridApiClient;
    constructor(apiClient: GridApiClient);
    private getUnsignedSigners;
    private isEmptySignature;
    private hasPublicKeySigned;
    sign(request: SignRequest$1): Promise<TransactionResult>;
    private signWithPrivyProvider;
    private signWithTurnkeyProvider;
    private signWithSolanaProvider;
    private signWithPasskeyProvider;
    private selectKeypairsFromSession;
    private selectKeypairsFromTransactionSigners;
    private aggregateSignatures;
}

type AuthProvider = 'turnkey' | 'passkey' | 'solana' | 'privy';
interface ErrorDetail {
    field?: string;
    code: string;
    message: string;
    suggestion: string;
    documentation: string;
}
declare class AuthorizationError extends Error {
    readonly code: string;
    readonly provider?: AuthProvider;
    readonly cause?: Error;
    readonly details?: ErrorDetail[];
    readonly timestamp?: string;
    readonly requestId?: string;
    constructor(message: string, code: string, provider?: AuthProvider, cause?: Error, details?: ErrorDetail[], timestamp?: string, requestId?: string);
    getFormattedMessage(): string;
}
declare class ProviderError extends Error {
    readonly provider: AuthProvider;
    readonly statusCode?: number;
    readonly cause?: Error;
    readonly details?: ErrorDetail[];
    readonly timestamp?: string;
    readonly requestId?: string;
    constructor(message: string, provider: AuthProvider, statusCode?: number, cause?: Error, details?: ErrorDetail[], timestamp?: string, requestId?: string);
    getFormattedMessage(): string;
}
interface UniversalKeyPair {
    publicKey: string;
    privateKey: string;
}
type KeyPairTag = 'primary' | 'backup' | 'solana' | 'passkey';
interface TaggedKeyPair extends UniversalKeyPair {
    provider: SignerProvider;
    tag: KeyPairTag;
}
type SessionSecrets = TaggedKeyPair[];
type Env = 'devnet' | 'mainnet' | 'testnet';
interface InitAuthRequest {
    email?: string;
    expiration?: number;
}
interface InitAuthResponse {
    data: any;
}
interface CompleteAuthRequest {
    expiration?: number;
}
interface CompleteAuthRequestWithOtp extends CompleteAuthRequest {
    otpCode: string;
    user: GridClientUserContext;
    sessionSecrets: SessionSecrets;
}
interface CompleteAuthResponse {
    data: any;
}
interface CompleteAuthAndCreateAccountRequest {
    otpCode: string;
    user: GridClientUserContext;
    sessionSecrets: SessionSecrets;
}
interface SignRequest {
    transaction: string;
    sessionSecrets: SessionSecrets;
}
interface SendTransactionRequest {
    signedTransactionPayload: TransactionResult;
    address: string;
}
interface ConfirmPayload {
    intentPayload: string;
    mpcPayload: string;
}
type SpendingLimitPeriod = 'one_time' | 'daily' | 'weekly' | 'monthly';
type ApiSpendingLimitPeriod = 'one_time' | 'day' | 'week' | 'month';
interface ApiSpendingLimitRequest {
    amount: string | number;
    mint: string;
    period: ApiSpendingLimitPeriod;
    transaction_signers?: string[];
    spending_limit_signers: string[];
}
interface SpendingLimitRequest {
    amount: string | number;
    mint: string;
    period: SpendingLimitPeriod;
    transaction_signers?: string[];
    spending_limit_signers: string[];
    destinations?: string[];
    expiration?: number;
}
interface GridTransactionResponse {
    data?: TransactionPayload | any;
    error?: string;
}
type PasskeyPermission = string;
interface PasskeyInfo {
    address: string;
    role: string;
    permissions: PasskeyPermission[];
    provider: string;
    added_at: string;
}
interface GetPasskeysResponse {
    account_address: string;
    passkey: PasskeyInfo | null;
}
interface PasskeyInput {
    address: string;
    role?: string;
    permissions?: PasskeyPermission[];
}
interface AddPasskeyRequest {
    passkey: PasskeyInput;
    transaction_signers?: string[];
}
interface AddPasskeyQueryParams {
    admin?: boolean;
}
interface AddPasskeyResponse {
    transaction: string;
    passkey: PasskeyInfo;
    threshold: number;
    status: string;
    expires_at: string;
}
type SignerRole = 'primary' | 'backup';
type SignerPermission = 'CAN_INITIATE' | 'CAN_EXECUTE' | 'CAN_VOTE';
interface AccountSigner {
    address: string;
    role: SignerRole;
    permissions: SignerPermission[];
    provider: string;
}
interface UpdateAccountRequest {
    signers?: AccountSigner[];
    threshold?: number;
    time_lock?: number;
    admin_address?: string | null;
    transaction_signers?: string[];
}
interface CreateAccountInput {
    email?: string;
    signer?: string;
}
interface AccountPolicies {
    signers: AccountSigner[];
    threshold: number;
    time_lock?: number | null;
    admin_address?: string | null;
}
interface EmailAccountRequest {
    type: 'email';
    email: string;
}
interface SignersAccountRequest {
    type: 'signers';
    policies: AccountPolicies;
    grid_user_id?: string | null;
    memo?: string;
}
type CreateAccountRequest = EmailAccountRequest | SignersAccountRequest | AccountPolicies;
interface EmailAccountResponse {
    type: 'email';
    email: string;
    status: string;
    otp_sent: boolean;
    created_at: string;
    expires_at: string;
    memo?: string;
}
interface SignersAccountResponse {
    type: 'signers';
    address: string;
    policies: AccountPolicies;
    grid_user_id: string;
    memo?: string;
}
type CreateAccountResponse = EmailAccountResponse | SignersAccountResponse;
interface GetAccountResponse {
    data: {
        type: 'signers' | 'email';
        address: string;
        policies?: AccountPolicies;
        grid_user_id: string;
        memo?: string;
        created_at?: string;
        status?: string;
    };
}
interface TokenBalance {
    token_address: string;
    amount: bigint;
    decimals: number;
    amount_decimal: string;
    symbol?: string;
    name?: string;
    logo?: string;
}
interface GetAccountBalancesQueryParams {
    limit?: number;
    page?: number;
}
interface AccountBalancesData {
    address: string;
    lamports: bigint;
    sol: number;
    tokens: TokenBalance[];
}
interface GetAccountBalancesResponse {
    data?: AccountBalancesData;
    error?: string;
}
interface PaymentDetails {
    account?: string;
    address?: string;
    currency: string;
    payment_rail?: string;
    external_account_id?: string;
}
interface CreatePaymentIntentRequest {
    amount: string;
    grid_user_id: string;
    source: PaymentDetails;
    destination: PaymentDetails;
    webhook_url?: string;
}
type CreatePaymentIntentApiResponse = any;
interface CreatePaymentIntentResponse {
    data?: {
        transactionPayload?: TransactionPayload;
    } & Omit<CreatePaymentIntentApiResponse, 'kms_payloads' | 'transaction_signers' | 'transaction'>;
    error?: string;
}
interface KmsPayload {
    provider: string;
    address: string;
    payload: string;
}
interface UpdateSpendingLimitRequest {
    amount?: string | number;
    mint?: string;
    period?: SpendingLimitPeriod;
    spending_limit_signers?: string[];
    destinations?: string[];
    expiration?: number;
    transaction_signers?: string[];
}
interface UseSpendingLimitRequest {
    amount: string | number;
    signer_address: string;
    recipient_address: string;
}
type KycType = 'individual' | 'business';
type KycEndorsement = 'ach' | 'sepa';
interface RequestKycLinkRequest {
    grid_user_id: string;
    type: KycType;
    email: string;
    full_name: string;
    endorsements?: KycEndorsement[];
    redirect_uri?: string;
}
interface KycLink {
    id: string;
    full_name: string;
    email: string;
    type: KycType;
    kyc_link: string;
    tos_link: string;
    kyc_status: KycStatus;
    rejection_reasons: string[];
    tos_status: TosStatus;
    created_at: string;
    customer_id: string;
    persona_inquiry_type: string;
}
interface RequestKycLinkResponse {
    data?: KycLink;
    error?: string;
}
type KycStatus = 'pending' | 'approved' | 'rejected' | 'under_review';
type TosStatus = 'pending' | 'approved' | 'rejected';
interface RejectionReason {
    code: string;
    message: string;
}
interface KycStatusData {
    id: string;
    account: string;
    type: KycType;
    status: KycStatus;
    tos_status: TosStatus;
    kyc_continuation_link?: string;
    rejection_reasons: RejectionReason[];
    requirements_due: string[];
    created_at: string;
    updated_at: string;
}
interface GetKycStatusResponse {
    data?: KycStatusData;
    error?: string;
}
type Currency = 'sol' | 'usdc' | 'usdt' | 'pyusd' | 'eurc';
interface FeeConfig {
    currency?: Currency;
    payer_address: string;
    self_managed_fees?: boolean;
}
interface PrepareArbitraryTransactionRequest {
    transaction: string;
    transaction_signers?: string[];
    account_signers?: string[];
    payer_address?: string;
    fee_config?: FeeConfig;
}
interface PrepareArbitraryTransactionQueryParams {
    debug?: boolean;
}
interface RemovePasskeyRequest {
    transaction_signers?: string[];
}
interface RemovePasskeyQueryParams {
    admin?: boolean;
}
interface RemovePasskeyResponse {
    transaction: string;
    removed_passkey: PasskeyInfo;
    threshold: number;
    status: string;
    expires_at: string;
}
type TransferState = 'awaiting_funds' | 'in_review' | 'funds_received' | 'payment_submitted' | 'payment_processed' | 'canceled' | 'error' | 'undeliverable' | 'returned' | 'refunded';
type ConfirmationStatus = 'pending' | 'confirmed';
type TransferDirection = 'inflow' | 'outflow';
interface Receipt {
    id: string;
    object: string;
    created_at: string;
}
interface BridgeTransferSource {
    payment_rail: PaymentRail;
    currency: BridgeCurrency;
    external_account_id?: string;
    bridge_wallet_id?: string;
    from_address?: string;
    omad?: string;
    imad?: string;
    bank_beneficiary_name?: string;
}
interface BridgeTransferDestination {
    currency: BridgeCurrency;
    payment_rail: PaymentRail;
    external_account_id?: string;
    bridge_wallet_id?: string;
    from_address?: string;
    wire_message?: string;
    sepa_reference?: string;
    swift_reference?: string;
}
interface BridgeTransferSourceDepositInstructions {
    amount?: string;
    currency: BridgeCurrency;
    deposit_message?: string;
    payment_rail: PaymentRail;
    from_address?: string;
    to_address?: string;
    bank_name?: string;
    bank_address?: string;
    bank_city?: string;
    bank_country?: string;
    bank_postal_code?: string;
    iban?: string;
    swift_bic?: string;
    beneficiary_name?: string;
    beneficiary_address?: string;
    beneficiary_city?: string;
    beneficiary_country?: string;
    beneficiary_postal_code?: string;
    routing_number?: string;
    account_number?: string;
    account_type?: string;
}
interface BridgeTransfer {
    id: string;
    state: TransferState;
    on_behalf_of: string;
    source_deposit_instructions?: BridgeTransferSourceDepositInstructions;
    amount: string;
    client_reference_id?: string;
    currency?: BridgeCurrency;
    developer_fee: string;
    source: BridgeTransferSource;
    destination: BridgeTransferDestination;
    receipt: Receipt;
    blockchain_memo?: string;
    created_at: string;
    updated_at: string;
}
interface SplTransfer {
    id: string;
    grid_user_id: string;
    main_account_address: string;
    mint: string;
    is_token_2022: boolean;
    signature: string;
    confirmation_status: ConfirmationStatus;
    from_address: string;
    to_address: string;
    amount: string;
    ui_amount: string;
    decimals: number;
    confirmed_at?: string;
    created_at: string;
    updated_at: string;
    direction?: TransferDirection;
    environment?: GridEnvironment;
    instruction_index?: number;
}
type TransferResponse = BridgeTransfer | SplTransfer;
interface GetTransfersOptions {
    payment_rail?: PaymentRail;
    status?: TransferState;
    currency?: BridgeCurrency;
    start_date?: string;
    end_date?: string;
    tx_hash?: string;
    limit?: number;
    cursor?: string;
}
interface GetTransfersResponse {
    data?: TransferResponse[];
    error?: string;
}
type BridgeCurrency = 'usd' | 'eur';
interface RequestVirtualAccountRequest {
    grid_user_id: string;
    currency: BridgeCurrency;
}
interface SourceDepositInstructions {
    currency: string;
    bank_beneficiary_name: string;
    bank_name: string;
    bank_address: string;
    bank_routing_number: string;
    bank_account_number: string;
    payment_rails: string[];
}
interface VirtualAccountDestination {
    currency: string;
    payment_rail: string;
    address: string;
}
interface VirtualAccount {
    id: string;
    customer_id: string;
    source_deposit_instructions: SourceDepositInstructions;
    destination: VirtualAccountDestination;
    status: string;
    developer_fee_percent: string;
}
interface RequestVirtualAccountResponse {
    data?: VirtualAccount;
    error?: string;
}
interface GetVirtualAccountsQueryParams {
    source_currency?: BridgeCurrency;
    destination_currency?: BridgeCurrency;
}
interface GetVirtualAccountsResponse {
    data?: VirtualAccount[];
    error?: string;
}
type StandingOrderFrequency = 'weekly' | 'monthly';
type StandingOrderStatus = 'active' | 'inactive' | 'cancelled' | 'completed';
type PaymentRail = 'ach_push' | 'ach_pull' | 'sepa' | 'faster_payments' | 'wire' | 'solana' | 'smart_account';
interface GridAccountDetails {
    account: string;
    currency: string;
    transaction_signers?: string[];
}
interface SolanaDetails {
    address: string;
    currency: string;
}
interface NewExternalAccountDetails {
    payment_rail: PaymentRail;
    currency: string;
    details: any;
}
interface ExistingExternalAccountDetails {
    payment_rail: PaymentRail;
    currency: string;
    external_account_id: string;
}
type Details = GridAccountDetails | SolanaDetails | NewExternalAccountDetails | ExistingExternalAccountDetails;
interface CreateStandingOrderRequest {
    amount: string;
    grid_user_id: string;
    source: Details;
    destination: Details;
    frequency: StandingOrderFrequency;
    start_date: string;
    end_date?: string;
}
interface CreateStandingOrderResponse {
    data?: {
        id: string;
        amount: string;
        ui_amount: string;
        currency: BridgeCurrency;
        payment_rail: PaymentRail;
        source: Details;
        destination: Details;
        frequency: StandingOrderFrequency;
        start_date: string;
        end_date?: string;
        status: StandingOrderStatus;
        transaction: string;
        kms_payloads: KmsPayload[];
        transaction_signers: string[];
        valid_until: string;
        created_at: string;
        transactionPayload: TransactionPayload;
    };
    error?: string;
}
interface GetStandingOrdersQueryParams {
    status?: StandingOrderStatus;
    currency?: string;
    start_date?: string;
    end_date?: string;
    tx_hash?: string;
    limit?: number;
    cursor?: string;
}
interface StandingOrder {
    id: string;
    amount: string;
    currency: string;
    period: StandingOrderFrequency;
    destinations: string[];
    status: StandingOrderStatus;
    remaining_amount: string;
    last_execution_date?: string;
    next_execution_date: string;
    created_at: string;
}
interface GetStandingOrdersResponse {
    data?: StandingOrder[];
    error?: string;
}
interface GetStandingOrderResponse {
    data?: StandingOrder;
    error?: string;
}
type SignerProvider = 'privy' | 'turnkey' | 'solana' | 'passkey' | 'pending' | 'external';
interface GridClientSigner {
    address?: string;
    email?: string;
    sessionKey?: any;
    type: 'primary' | 'backup';
    provider?: SignerProvider;
}
interface GridClientUserContext {
    address?: string;
    grid_user_id?: string;
    signers: GridClientSigner[];
    session?: Session;
    email?: string;
}
interface EncryptedAuthorizationKey {
    encryption_type: string;
    encapsulated_key: string;
    ciphertext: string;
}
type WalletChainType = 'Solana' | 'Ethereum' | 'Cosmos' | 'Stellar' | 'Sui' | 'Tron' | 'bitcoin-segwit';
interface AdditionalSigner {
    signer_id: string;
    override_policy_ids?: string[];
}
interface Wallet {
    id: string;
    address: string;
    public_key?: string;
    created_at: number;
    chain_type: WalletChainType;
    policy_ids: string[];
    owner_id?: string;
    additional_signers: AdditionalSigner[];
    exported_at?: number;
    imported_at?: number;
}
interface Session {
    encrypted_authorization_key?: EncryptedAuthorizationKey;
    authorization_key?: string;
    expires_at: number;
    wallets: Wallet[];
}
interface ClientContext {
    environment: GridEnvironment;
    config: GridApiConfig;
    solanaRpcUrl?: string;
}
interface GridClientContext {
    client: ClientContext;
    user: GridClientUserContext;
}

interface AuthenticationRequest {
    email?: string;
    keypair?: UniversalKeyPair;
    passkeyId?: string;
    provider?: SignerProvider;
    expiration?: number;
}
interface AuthenticationContext {
    provider: SignerProvider;
    sessionId?: string;
    authPublicKey?: string;
    email?: string;
    keypair?: UniversalKeyPair;
}
declare class AuthenticationManager {
    private gridApiClient;
    private currentContext?;
    constructor(apiClient: GridApiClient);
    authenticate(request: AuthenticationRequest): Promise<InitAuthResponse>;
    complete(request: CompleteAuthRequestWithOtp | CompleteAuthAndCreateAccountRequest): Promise<CompleteAuthResponse>;
    completeAndCreateAccount(request: CompleteAuthAndCreateAccountRequest): Promise<any>;
    generateSessionSecrets(): Promise<SessionSecrets>;
    generateKeyPair(provider: SignerProvider): Promise<UniversalKeyPair>;
    private initiateEmailAuth;
    private validateEOAWallet;
    private initiatePasskeyAuth;
    private completePrivyAuth;
    private completeTurnkeyAuth;
    private completePrivyAuthAndCreateAccount;
    private completeTurnkeyAuthAndCreateAccount;
    private determineAuthType;
    getCurrentProvider(): SignerProvider | undefined;
    getCurrentContext(): AuthenticationContext | undefined;
    clearContext(): void;
}

interface GridClientInterface {
    initAuth(request: AuthenticationRequest): Promise<InitAuthResponse>;
    completeAuth(request: CompleteAuthRequestWithOtp): Promise<CompleteAuthResponse>;
    completeAuthAndCreateAccount(request: CompleteAuthAndCreateAccountRequest): Promise<any>;
    generateKeyPair(provider?: SignerProvider): Promise<UniversalKeyPair>;
    generateSessionSecrets(): Promise<SessionSecrets>;
    extractSignableTransaction(transactionData: GridTransactionResponse): VersionedTransaction;
    setExternallySignedTransaction(transactionData: GridTransactionResponse, externallySignedTransaction: VersionedTransaction): GridTransactionResponse;
    sign(request: SignRequest$1): Promise<TransactionResult>;
    send(request: SendTransactionRequest): Promise<any>;
    signAndSend(request: SignAndSendRequest): Promise<any>;
    createAccount(input: CreateAccountInput | CreateAccountRequest): Promise<CreateAccountResponse>;
    getAccount(accountAddress: string): Promise<ApiResponse>;
    updateAccount(accountAddress: string, request: UpdateAccountRequest, admin?: boolean): Promise<GridTransactionResponse>;
    getAccountBalances(accountAddress: string, queryParams?: GetAccountBalancesQueryParams): Promise<GetAccountBalancesResponse>;
    getTransfers(accountAddress: string, options?: GetTransfersOptions): Promise<ApiResponse>;
    createSpendingLimit(smartAccountAddress: string, request: SpendingLimitRequest): Promise<GridTransactionResponse>;
    updateSpendingLimit(accountAddress: string, spendingLimitAddress: string, request: UpdateSpendingLimitRequest): Promise<GridTransactionResponse>;
    deleteSpendingLimit(accountAddress: string, spendingLimitAddress: string): Promise<GridTransactionResponse>;
    useSpendingLimit(accountAddress: string, spendingLimitAddress: string, request: UseSpendingLimitRequest): Promise<GridTransactionResponse>;
    getPasskeys(accountAddress: string): Promise<GetPasskeysResponse>;
    addPasskey(accountAddress: string, request: AddPasskeyRequest, queryParams?: AddPasskeyQueryParams): Promise<AddPasskeyResponse>;
    removePasskey(accountAddress: string, passkeyAddress: string, request: RemovePasskeyRequest, queryParams?: RemovePasskeyQueryParams): Promise<RemovePasskeyResponse>;
    createPaymentIntent(accountAddress: string, request: CreatePaymentIntentRequest): Promise<CreatePaymentIntentResponse>;
    requestKycLink(accountAddress: string, request: RequestKycLinkRequest): Promise<RequestKycLinkResponse>;
    getKycStatus(accountAddress: string, kycId: string): Promise<GetKycStatusResponse>;
    prepareArbitraryTransaction(accountAddress: string, request: PrepareArbitraryTransactionRequest, queryParams?: PrepareArbitraryTransactionQueryParams): Promise<GridTransactionResponse>;
    requestVirtualAccount(accountAddress: string, request: RequestVirtualAccountRequest): Promise<RequestVirtualAccountResponse>;
    getVirtualAccounts(accountAddress: string, queryParams?: GetVirtualAccountsQueryParams): Promise<GetVirtualAccountsResponse>;
    createStandingOrder(accountAddress: string, request: CreateStandingOrderRequest): Promise<CreateStandingOrderResponse>;
    getStandingOrders(accountAddress: string, queryParams?: GetStandingOrdersQueryParams): Promise<GetStandingOrdersResponse>;
    getStandingOrder(accountAddress: string, standingOrderId: string): Promise<GetStandingOrderResponse>;
    getContext(): GridClientContext;
    clearAuthContext(): void;
}

declare class GridClient implements GridClientInterface {
    private apiClient;
    private authManager;
    private signingManager;
    protected apiConfig: GridApiConfig;
    private solanaRpcUrl?;
    private context;
    private createAuthError;
    constructor(apiConfig: GridApiConfig);
    extractSignableTransaction(transactionData: GridTransactionResponse): VersionedTransaction;
    setExternallySignedTransaction(transactionData: GridTransactionResponse, externallySignedTransaction: VersionedTransaction): GridTransactionResponse;
    initAuth(request: InitAuthRequest | AuthenticationRequest): Promise<InitAuthResponse>;
    completeAuth(request: CompleteAuthRequestWithOtp): Promise<CompleteAuthResponse>;
    completeAuthAndCreateAccount(request: CompleteAuthAndCreateAccountRequest): Promise<any>;
    generateSessionSecrets(): Promise<SessionSecrets>;
    generateKeyPair(provider?: SignerProvider): Promise<UniversalKeyPair>;
    sign(request: SignRequest$1): Promise<TransactionResult>;
    signAndSend(request: SignAndSendRequest): Promise<any>;
    send(request: SendTransactionRequest): Promise<any>;
    createAccount(input: CreateAccountInput | CreateAccountRequest): Promise<CreateAccountResponse>;
    getAccount(accountAddress: string): Promise<ApiResponse>;
    updateAccount(accountAddress: string, request: UpdateAccountRequest, admin?: boolean): Promise<GridTransactionResponse>;
    getAccountBalances(accountAddress: string, queryParams?: GetAccountBalancesQueryParams): Promise<ApiResponse>;
    getTransfers(accountAddress: string, options?: GetTransfersOptions): Promise<ApiResponse>;
    createSpendingLimit(smartAccountAddress: string, request: SpendingLimitRequest): Promise<GridTransactionResponse>;
    updateSpendingLimit(accountAddress: string, spendingLimitAddress: string, request: UpdateSpendingLimitRequest): Promise<GridTransactionResponse>;
    deleteSpendingLimit(accountAddress: string, spendingLimitAddress: string): Promise<GridTransactionResponse>;
    useSpendingLimit(accountAddress: string, spendingLimitAddress: string, request: UseSpendingLimitRequest): Promise<GridTransactionResponse>;
    getPasskeys(accountAddress: string): Promise<GetPasskeysResponse>;
    addPasskey(accountAddress: string, request: AddPasskeyRequest, queryParams?: AddPasskeyQueryParams): Promise<AddPasskeyResponse>;
    removePasskey(accountAddress: string, passkeyAddress: string, request: RemovePasskeyRequest, queryParams?: RemovePasskeyQueryParams): Promise<RemovePasskeyResponse>;
    createPaymentIntent(accountAddress: string, request: CreatePaymentIntentRequest): Promise<CreatePaymentIntentResponse>;
    requestKycLink(accountAddress: string, request: RequestKycLinkRequest): Promise<ApiResponse>;
    getKycStatus(accountAddress: string, kycId: string): Promise<ApiResponse>;
    prepareArbitraryTransaction(accountAddress: string, request: PrepareArbitraryTransactionRequest, queryParams?: PrepareArbitraryTransactionQueryParams): Promise<GridTransactionResponse>;
    requestVirtualAccount(accountAddress: string, request: RequestVirtualAccountRequest): Promise<ApiResponse>;
    getVirtualAccounts(accountAddress: string, queryParams?: GetVirtualAccountsQueryParams): Promise<GetVirtualAccountsResponse>;
    createStandingOrder(accountAddress: string, request: CreateStandingOrderRequest): Promise<CreateStandingOrderResponse>;
    getStandingOrders(accountAddress: string, queryParams?: GetStandingOrdersQueryParams): Promise<ApiResponse>;
    getStandingOrder(accountAddress: string, standingOrderId: string): Promise<ApiResponse>;
    getContext(): GridClientContext;
    updateContext(updates: Partial<GridClientUserContext>): void;
    clearAuthContext(): void;
    private constructAccountPayload;
}

export { type AccountBalancesData, type AddPasskeyQueryParams, type AddPasskeyRequest, type AddPasskeyResponse, type AuthenticationContext, AuthenticationManager, type AuthenticationRequest, AuthorizationError, type BridgeCurrency, type BridgeTransfer, type BridgeTransferDestination, type BridgeTransferSource, type BridgeTransferSourceDepositInstructions, type CompleteAuthAndCreateAccountRequest, type CompleteAuthRequest, type CompleteAuthResponse, type ConfirmationStatus, type CreateAccountInput, type CreateAccountRequest, type CreateAccountResponse, type CreatePaymentIntentRequest, type CreatePaymentIntentResponse, type CreateStandingOrderRequest, type CreateStandingOrderResponse, type Currency, type FeeConfig, type GetAccountBalancesQueryParams, type GetAccountBalancesResponse, type GetAccountResponse, type GetKycStatusResponse, type GetPasskeysResponse, type GetStandingOrderResponse, type GetStandingOrdersQueryParams, type GetStandingOrdersResponse, type GetTransfersOptions, type GetTransfersResponse, type GetVirtualAccountsQueryParams, type GetVirtualAccountsResponse, GridApiClient, type GridApiConfig, GridClient, type GridClientContext, type GridClientInterface, type GridClientSigner, type GridClientUserContext, type GridEnvironment, type GridTransactionResponse, type InitAuthRequest, type InitAuthResponse, type KeyPairTag, type KycEndorsement, type KycLink, type KycStatus, type KycStatusData, type KycType, type PaymentRail, type PrepareArbitraryTransactionQueryParams, type PrepareArbitraryTransactionRequest, ProviderError, type Receipt, type RemovePasskeyQueryParams, type RemovePasskeyRequest, type RemovePasskeyResponse, type RequestKycLinkRequest, type RequestKycLinkResponse, type RequestVirtualAccountRequest, type RequestVirtualAccountResponse, type SendTransactionRequest, type SessionSecrets, type SignRequest$1 as SignRequest, type SignResult, type SignatureResult, type SignerPermission, type SignerProvider, type SignerRole, SigningManager, type SourceDepositInstructions, type SpendingLimitPeriod, type SpendingLimitRequest, type SplTransfer, type TosStatus, type TransferDirection, type TransferResponse, type TransferState, type UniversalKeyPair, type UpdateAccountRequest, type UpdateSpendingLimitRequest, type UseSpendingLimitRequest, type VirtualAccount, type VirtualAccountDestination };
