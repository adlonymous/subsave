'use strict';var Z=require('uuid'),web3_js=require('@solana/web3.js'),ve=require('canonicalize'),buffer=require('buffer'),p256=require('@noble/curves/p256');require('@noble/hashes/hmac');var chacha=require('@noble/ciphers/chacha'),sha256=require('@noble/hashes/sha256'),sha256Uint8array=require('sha256-uint8array'),encoding=require('@turnkey/encoding'),w=require('@noble/hashes/hkdf');require('@noble/hashes/utils');function _interopDefault(e){return e&&e.__esModule?e:{default:e}}function _interopNamespace(e){if(e&&e.__esModule)return e;var n=Object.create(null);if(e){Object.keys(e).forEach(function(k){if(k!=='default'){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:true,get:function(){return e[k]}});}})}n.default=e;return Object.freeze(n)}var Z__namespace=/*#__PURE__*/_interopNamespace(Z);var ve__default=/*#__PURE__*/_interopDefault(ve);var w__namespace=/*#__PURE__*/_interopNamespace(w);var we=Object.defineProperty;var u=(o,e)=>we(o,"name",{value:e,configurable:true}),Se=(o=>typeof require<"u"?require:typeof Proxy<"u"?new Proxy(o,{get:(e,t)=>(typeof require<"u"?require:e)[t]}):o)(function(o){if(typeof require<"u")return require.apply(this,arguments);throw Error('Dynamic require of "'+o+'" is not supported')});var D=class D{constructor(e){if(e.environment&&!["sandbox","production"].includes(e.environment))throw new Error(`Invalid Grid environment: '${e.environment}'. Must be 'sandbox' or 'production'.`);if(!e.baseUrl)throw new Error("Base URL is required");this.environment=e.environment||"sandbox",this.baseUrl=`${e.baseUrl}/api/grid/v1`,this.config={timeout:1e4,retryAttempts:3,...e},this.config.apiKey;}generateIdempotencyKey(){return Z__namespace.v4()}hasApiKey(){return !!this.config.apiKey}requiresApiKey(e){return  true}async request(e,t={}){let{method:r="GET",data:n,headers:i={}}=t;if(this.requiresApiKey(e)&&!this.config.apiKey)return {success:false,error:"API key is required for this operation. Initialize GridClient with an API key to use this feature. Operations that don't require an API key: generateKeyPair(), generateSessionSecrets(), getContext(), updateContext(), clearAuthContext()",code:"API_KEY_REQUIRED"};let c=`${this.baseUrl}${e}`,p={"Content-Type":"application/json","x-grid-environment":this.environment,...i};(r==="POST"||r==="PUT"||r==="PATCH")&&(p["x-idempotency-key"]=this.generateIdempotencyKey()),this.config.apiKey&&(p.Authorization=`Bearer ${this.config.apiKey}`);try{let d=await fetch(c,{method:r,headers:p,body:n?JSON.stringify(n):void 0}),y=await d.text(),g;try{g=JSON.parse(y);}catch{return {success:!1,error:y||"Invalid response format",code:d.status.toString()}}if(!d.ok){let l=g?.message||d.statusText||"API request failed",m=g?.details||g;return {success:!1,error:l,code:d.status.toString(),details:m,timestamp:g?.timestamp,requestId:g?.request_id}}return {success:!0,data:g.data?g.data:g}}catch(d){return {success:false,error:d instanceof Error?d.message:"Unknown error",code:"NETWORK_ERROR"}}}async createPasskeySession(e){return this.request("/api/v1/passkeys",{method:"POST",headers:{"x-squads-network":e.env},data:e})}async initAuthWithTurnkey(e){let t={email:e.email,app_name:e.appName,app_icon_url:e.appIconUrl,expiration:e.expiration};return this.request("/auth/init",{method:"POST",data:t})}async completeTurnkeyAuth(e){let t={mpc_primary_id:e.mpcPrimaryId,otp_id:e.otpId,otp_code:e.otpCode,auth_public_key:e.authPublicKey,expiration:e.expiration};return this.request("/auth/complete",{method:"POST",data:t})}async completeTurnkeyAuthAndCreateAccount(e){let t={mpc_primary_id:e.mpcPrimaryId,otp_id:e.otpId,otp_code:e.otpCode,auth_public_key:e.authPublicKey,expiration:e.expiration};return this.request("/auth/complete-and-create-account",{method:"POST",data:t})}async initAuthWithPrivy(e){let t={email:e.email,provider:e.provider||"privy",expiration:e.expiration};return this.request("/auth",{method:"POST",data:t})}async completePrivyAuthAndCreateAccount(e){let t={email:e.email,otp_code:e.otpCode,provider:"privy",kms_provider_config:{encryption_public_key:e.authPublicKey},expiration:e.expiration};return this.request("/accounts/verify",{method:"POST",data:t})}async completePrivyAuth(e){let t={email:e.email,otp_code:e.otpCode,kms_provider:"privy",kms_provider_config:{encryption_public_key:e.authPublicKey},expiration:e.expiration};return this.request("/auth/verify",{method:"POST",data:t})}async sendTransaction(e,t,r){let n=`/accounts/${e}/transactions/${t}/confirm?use-mpc-provider=true`;return this.request(n,{method:"POST",data:r})}async submitPrivyTransaction(e,t){let r=`/accounts/${e}/submit`;return this.request(r,{method:"POST",data:t})}async submitTransaction(e,t){let r=`/accounts/${e}/submit`;return this.request(r,{method:"POST",data:t})}async getAccount(e){return this.request(`/accounts/${e}`,{method:"GET"})}async getTransactions(e){return this.request(`/accounts/${e}/transactions`,{method:"GET"})}async getAccountBalances(e,t){let r=`/accounts/${e}/balances`;if(t){let n=new URLSearchParams;t.limit!==void 0&&n.append("limit",t.limit.toString()),t.page!==void 0&&n.append("page",t.page.toString()),n.toString()&&(r+=`?${n.toString()}`);}return this.request(r,{method:"GET"})}async getTransfers(e,t){let r=`/accounts/${e}/transfers`;if(t){let n=new URLSearchParams;t.payment_rail!==void 0&&n.append("type",t.payment_rail),t.status!==void 0&&n.append("status",t.status),t.currency!==void 0&&n.append("currency",t.currency),t.start_date!==void 0&&n.append("start_date",t.start_date),t.end_date!==void 0&&n.append("end_date",t.end_date),t.tx_hash!==void 0&&n.append("tx_hash",t.tx_hash),t.limit!==void 0&&n.append("limit",t.limit.toString()),t.cursor!==void 0&&n.append("cursor",t.cursor),n.toString()&&(r+=`?${n.toString()}`);}return this.request(r,{method:"GET"})}async getBalance(e){return this.getAccountBalances(e)}async createSpendingLimit(e,t){let r=`/accounts/${e}/spending-limit`;return this.request(r,{method:"POST",data:t})}async updateSpendingLimit(e,t,r){let n=`/accounts/${e}/spending-limit/${t}`;return this.request(n,{method:"PATCH",data:r})}async deleteSpendingLimit(e,t){let r=`/accounts/${e}/spending-limit/${t}`;return this.request(r,{method:"DELETE",data:{transaction_signers:[]}})}async useSpendingLimit(e,t,r){let n=`/accounts/${e}/spending-limit/${t}/transactions`;return this.request(n,{method:"POST",data:r})}async getPasskeys(e){let t=`/accounts/${e}/passkeys`;return this.request(t,{method:"GET"})}async addPasskey(e,t,r){let n=`/accounts/${e}/passkeys/transaction`,i=r?.admin?"?admin=true":"";return this.request(n+i,{method:"POST",data:t})}async removePasskey(e,t,r,n){let i=`/accounts/${e}/passkeys/${t}/transaction`,c=n?.admin?"?admin=true":"";return this.request(i+c,{method:"DELETE",data:r})}async createAccount(e){return this.request("/accounts",{method:"POST",data:e})}async updateAccount(e,t,r){let n=`/accounts/${e}`,i=r?"?admin=true":"";return this.request(n+i,{method:"PATCH",data:t})}async createPaymentIntent(e,t){let r=`/accounts/${e}/payment-intent`;return this.request(r,{method:"POST",data:t})}async requestKycLink(e,t){let r=`/accounts/${e}/kyc`;return this.request(r,{method:"POST",data:t})}async getKycStatus(e,t){let r=`/accounts/${e}/kyc/${t}`;return this.request(r,{method:"GET"})}async prepareArbitraryTransaction(e,t,r){let n=`/accounts/${e}/transactions`;if(r){let i=new URLSearchParams;r.debug!==void 0&&i.append("debug",r.debug.toString()),i.toString()&&(n+=`?${i.toString()}`);}return this.request(n,{method:"POST",data:t})}async requestVirtualAccount(e,t){let r=`/accounts/${e}/virtual-account`;return this.request(r,{method:"POST",data:t})}async getVirtualAccounts(e,t){let r=`/accounts/${e}/virtual-accounts`;if(t){let n=new URLSearchParams;t.source_currency!==void 0&&n.append("source_currency",t.source_currency),t.destination_currency!==void 0&&n.append("destination_currency",t.destination_currency),n.toString()&&(r+=`?${n.toString()}`);}return this.request(r,{method:"GET"})}async createStandingOrder(e,t){let r=`/accounts/${e}/standing-order-intent`;return await this.request(r,{method:"POST",data:t})}async getStandingOrders(e,t){let r=`/accounts/${e}/standing-orders`;if(t){let n=new URLSearchParams;t.status!==void 0&&n.append("status",t.status),t.currency!==void 0&&n.append("currency",t.currency),t.start_date!==void 0&&n.append("start_date",t.start_date),t.end_date!==void 0&&n.append("end_date",t.end_date),t.tx_hash!==void 0&&n.append("tx_hash",t.tx_hash),t.limit!==void 0&&n.append("limit",t.limit.toString()),t.cursor!==void 0&&n.append("cursor",t.cursor),n.toString()&&(r+=`?${n.toString()}`);}return this.request(r,{method:"GET"})}async getStandingOrder(e,t){let r=`/accounts/${e}/standing-order/${t}`;return this.request(r,{method:"GET"})}async signWithPrivy(e){return this.request("/sign/privy",{method:"POST",data:e})}async signWithTurnkey(e){return this.request("/sign/turnkey",{method:"POST",data:e})}async signWithPasskey(e){return this.request("/sign/passkey",{method:"POST",data:e})}};u(D,"GridApiClient");var P=D;var B=class B extends Error{constructor(t,r,n,i,c,p,d){super(t);this.code=r;this.provider=n;this.cause=i;this.details=c;this.timestamp=p;this.requestId=d;this.name="AuthorizationError";}getFormattedMessage(){let t=this.message;if(this.details&&this.details.length>0){let r=this.details.filter(i=>i.suggestion&&i.suggestion.trim()).map(i=>i.suggestion);r.length>0&&(t+=`

Suggestions:
${r.map(i=>`\u2022 ${i}`).join(`
`)}`);let n=this.details.filter(i=>i.documentation&&i.documentation.trim()).map(i=>i.documentation);n.length>0&&(t+=`

Documentation: ${n[0]}`);}return t}};u(B,"AuthorizationError");var a=B;var N=class N extends Error{constructor(t,r,n,i,c,p,d){super(t);this.provider=r;this.statusCode=n;this.cause=i;this.details=c;this.timestamp=p;this.requestId=d;this.name="ProviderError";}getFormattedMessage(){let t=this.message;if(this.details&&this.details.length>0){let r=this.details.filter(i=>i.suggestion&&i.suggestion.trim()).map(i=>i.suggestion);r.length>0&&(t+=`

Suggestions:
${r.map(i=>`\u2022 ${i}`).join(`
`)}`);let n=this.details.filter(i=>i.documentation&&i.documentation.trim()).map(i=>i.documentation);n.length>0&&(t+=`

Documentation: ${n[0]}`);}return t}};u(N,"ProviderError");var s=N;var F=class F{static validateProviderOptions(e){if(!e)throw new a("Provider options are required","INVALID_OPTIONS");if(!e.provider)throw new a("Provider type is required","MISSING_PROVIDER_TYPE");if(e.config)switch(e.provider){case "turnkey":this.validateTurnkeyConfig(e.config);break;case "passkey":this.validatePasskeyConfig(e.config);break;case "solana":this.validateSolanaConfig(e.config);break;default:throw new a(`Unknown provider type: ${e.provider}`,"UNKNOWN_PROVIDER",e.provider)}}static validateTurnkeyConfig(e){this.validateBaseProviderConfig(e);}static validateBaseProviderConfig(e){if(e.timeout&&(e.timeout<1e3||e.timeout>3e5))throw new a("Timeout must be between 1000ms and 300000ms","INVALID_TIMEOUT")}static validatePasskeyConfig(e){this.validateBaseProviderConfig(e);}static validateSolanaConfig(e){this.validateBaseProviderConfig(e);}static validateAuthorizationIntent(e){if(!e)throw new a("Authorization intent is required","MISSING_INTENT");if(!e.address)throw new a("Smart account address is required","MISSING_SMART_ACCOUNT");try{new web3_js.PublicKey(e.address);}catch{throw new a("Invalid smart account address","INVALID_SMART_ACCOUNT")}if(!e.operation)throw new a("Operation is required","MISSING_OPERATION");this.validateSmartAccountOperation(e.operation),e.signers&&e.signers.forEach((t,r)=>{try{new web3_js.PublicKey(t);}catch{throw new a(`Invalid signer address at index ${r}`,"INVALID_SIGNER")}});}static validateSmartAccountOperation(e){if(!e.type)throw new a("Operation type is required","MISSING_OPERATION_TYPE");let t=["transfer","swap","stake","custom"];if(!t.includes(e.type))throw new a(`Invalid operation type. Must be one of: ${t.join(", ")}`,"INVALID_OPERATION_TYPE");if(e.type==="transfer"){if(!e.amount)throw new a("Transfer amount is required","MISSING_TRANSFER_AMOUNT");if(!e.recipient)throw new a("Transfer recipient is required","MISSING_TRANSFER_RECIPIENT");try{new web3_js.PublicKey(e.recipient);}catch{throw new a("Invalid transfer recipient address","INVALID_TRANSFER_RECIPIENT")}if(e.token)try{new web3_js.PublicKey(e.token);}catch{throw new a("Invalid token address","INVALID_TOKEN_ADDRESS")}}}static isValidPublicKey(e){try{return new web3_js.PublicKey(e),!0}catch{return  false}}static isValidEmail(e){return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(e)}static sanitizeConfig(e){let t={...e};return t.privateKey&&(t.privateKey="***REDACTED***"),t.mnemonic&&(t.mnemonic="***REDACTED***"),t.clientSecret&&(t.clientSecret="***REDACTED***"),t}};u(F,"ValidationUtils");var v=F;sha256.sha256.outputLen;var re=16,Te=1,ke=3;function b(o){let e=new Uint8Array(2);return e[0]=o>>>8&255,e[1]=o&255,e}u(b,"i2osp2");ne(new TextEncoder().encode("KEM"),b(re));ne(new TextEncoder().encode("HPKE"),b(re),b(Te),b(ke));function ne(...o){let e=o.reduce((n,i)=>n+i.length,0),t=new Uint8Array(e),r=0;for(let n of o)t.set(n,r),r+=n.length;return t}u(ne,"concat");function Ce(o){let e=new Uint8Array([48,129,135,2,1,0,48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7,4,109]),t=new Uint8Array([48,107,2,1,1,4,32,...o]),r=new Uint8Array(e.length+t.length);return r.set(e),r.set(t,e.length),r}u(Ce,"createPKCS8PrivateKey");function _e(o){let e=new Uint8Array([48,19,6,7,42,134,72,206,61,2,1,6,8,42,134,72,206,61,3,1,7]),t=new Uint8Array([3,o.length+1,0]),r=e.length+t.length+o.length,n=new Uint8Array(2+r);return n[0]=48,n[1]=r,n.set(e,2),n.set(t,2+e.length),n.set(o,2+e.length+t.length),n}u(_e,"createSPKIPublicKey");async function K(){let o=p256.p256.utils.randomPrivateKey(),e=p256.p256.getPublicKey(o),t=_e(e),r=Ce(o);return {publicKey:buffer.Buffer.from(t).toString("base64"),privateKey:buffer.Buffer.from(r).toString("base64")}}u(K,"generateHPKEKeyPair");function ee(o){for(let e=0;e<o.length-33;e++)if(o[e]===4&&o[e+1]===32)return o.slice(e+2,e+34);throw new Error("Could not extract private key from DER format")}u(ee,"extractPrivateKeyFromDER");function q(o,e){let t=buffer.Buffer.from(o,"base64").toString("utf8"),r=JSON.parse(t),n=ve__default.default(r),i=buffer.Buffer.from(n),c;if(e.includes("BEGIN PRIVATE KEY")){let g=e.replace(/-----BEGIN PRIVATE KEY-----|\-----END PRIVATE KEY-----|\s/g,""),l=buffer.Buffer.from(g,"base64");c=ee(l);}else {let g=buffer.Buffer.from(e,"base64");c=ee(g);}let p=sha256.sha256(i),y=p256.p256.sign(p,c).toDERRawBytes();return buffer.Buffer.from(y).toString("base64")}u(q,"signPayload");var V=u(async()=>{try{return web3_js.Keypair.generate()}catch(o){throw new Error(`Failed to generate Solana key pair: ${o}`)}},"generateSolanaKeyPair");var E=u(async()=>{try{let{generateP256KeyPair:o}=await import('@turnkey/crypto');try{let e=o();return {publicKey:e.publicKey,privateKey:e.privateKey,publicKeyUncompressed:e.publicKeyUncompressed}}catch(e){throw new Error(`Failed to generate Turnkey key pair: ${e}`)}}catch(o){throw new Error(`Failed to generate Turnkey key pair: ${o}`)}},"generateTurnkeyKeyPair"),ie=u(async(o,e)=>{try{let{decryptCredentialBundle:t}=await import('@turnkey/crypto');try{return t(o,e)}catch(r){throw new Error(`Failed to decrypt credentials: ${r}`)}}catch(t){throw new Error(`Failed to generate Turnkey key pair: ${t}`)}},"decryptCredentials"),se=u(async o=>{let{getPublicKey:e}=await import('@turnkey/crypto');return encoding.uint8ArrayToHexString(e(encoding.uint8ArrayFromHexString(o),true))},"getPublicKeyFromDecryptedData"),ae=u(async o=>{let{p256:e}=Se("@noble/curves/p256"),t=sha256Uint8array.createHash().update(o.payload).digest();return e.sign(t,o.privateKey).toDERHex()},"signWithApiKey");var Q=class Q{constructor(e){this.gridApiClient=e;}async authenticate(e){let t=this.determineAuthType(e);switch(t){case "privy":case "turnkey":return this.initiateEmailAuth(e.email,t,e.expiration);case "solana":return this.validateEOAWallet(e.keypair);case "passkey":return this.initiatePasskeyAuth(e.passkeyId);default:throw new a(`Unsupported authentication type: ${t}`,"UNSUPPORTED_AUTH_TYPE")}}async complete(e){return this.completePrivyAuth(e)}async completeAndCreateAccount(e){return this.completePrivyAuthAndCreateAccount(e)}async generateSessionSecrets(){let e=[{type:"privy",tag:"primary"},{type:"turnkey",tag:"backup"},{type:"solana",tag:"solana"},{type:"passkey",tag:"passkey"}],t=[];for(let{type:r,tag:n}of e)try{let i=await this.generateKeyPair(r);t.push({publicKey:i.publicKey,privateKey:i.privateKey,provider:r,tag:n});}catch{}if(t.length===0)throw new s("Failed to generate keypairs with any provider. Please check provider configurations.","privy");return t}async generateKeyPair(e){switch(e){case "privy":let t=await K();return {publicKey:t.publicKey,privateKey:t.privateKey};case "turnkey":return E();case "solana":let r=await V();return {publicKey:r.publicKey.toString(),privateKey:Buffer.from(r.secretKey).toString("hex")};case "passkey":let n=await V();return {publicKey:n.publicKey.toString(),privateKey:Buffer.from(n.secretKey).toString("hex")};default:throw new a(`Keypair generation not supported for provider: ${e}`,"UNSUPPORTED_PROVIDER")}}async initiateEmailAuth(e,t,r){if(!v.isValidEmail(e))throw new a("Invalid email format","INVALID_EMAIL");let n=await this.generateKeyPair(t);if(this.currentContext={provider:t,email:e,authPublicKey:n.publicKey},t==="privy"){let i={email:e,expiration:r},c=await this.gridApiClient.initAuthWithPrivy(i);if(!c.success)throw new s(c.error||"Failed to initiate Privy authentication",t,c.code?parseInt(c.code):void 0);return c.data}else {let i={email:e,expiration:r},c=await this.gridApiClient.initAuthWithTurnkey(i);if(!c.success)throw new s(c.error||"Failed to initiate Turnkey authentication",t,c.code?parseInt(c.code):void 0);return {data:c.data}}}async validateEOAWallet(e){if(!e.publicKey||!e.privateKey)throw new a("Invalid keypair: missing public or private key","INVALID_KEYPAIR");return this.currentContext={provider:"solana",keypair:e},{data:{authenticated:true,provider:"solana",publicKey:e.publicKey}}}async initiatePasskeyAuth(e){throw new a("Passkey authentication not yet implemented","NOT_IMPLEMENTED")}async completePrivyAuth(e){let{otpCode:t,user:r,sessionSecrets:n}=e,i=this.currentContext?.email||r.email;if(!i)throw new a("Email is required for Privy authentication","MISSING_EMAIL");let c=n.find(y=>y.provider==="privy");if(!c)throw new a("Privy keypair not found","MISSING_KEYPAIR");let p={email:i,otpCode:t,authPublicKey:c.publicKey},d=await this.gridApiClient.completePrivyAuth(p);if(!d.success)throw new s(d.error||"Failed to complete Privy authentication","privy",d.code?parseInt(d.code):void 0);return d.data}async completeTurnkeyAuth(e){let{otpCode:t,user:r,sessionSecrets:n}=e;if(!(this.currentContext?.email||r.email))throw new a("Email is required for Turnkey authentication","MISSING_EMAIL");let c=n.find(y=>y.provider==="turnkey");if(!c)throw new a("Turnkey keypair not found","MISSING_KEYPAIR");let p={mpcPrimaryId:"placeholder_primary_id",otpId:"placeholder_otp_id",otpCode:t,authPublicKey:c.publicKey},d=await this.gridApiClient.completeTurnkeyAuth(p);if(!d.success)throw new s(d.error||"Failed to complete Turnkey authentication","turnkey",d.code?parseInt(d.code):void 0);return d.data}async completePrivyAuthAndCreateAccount(e){let{otpCode:t,user:r,sessionSecrets:n}=e,i=this.currentContext?.email||r.email;if(!i)throw new a("Email is required","MISSING_EMAIL");let c=n.find(y=>y.provider==="privy");if(!c)throw new a("Privy keypair not found","MISSING_KEYPAIR");let p={email:i,otpCode:t,authPublicKey:c.publicKey},d=await this.gridApiClient.completePrivyAuthAndCreateAccount(p);if(!d.success)throw new s(d.error||"Failed to complete Privy auth and create account","privy",d.code?parseInt(d.code):void 0);return d.data}async completeTurnkeyAuthAndCreateAccount(e){let{otpCode:t,user:r,sessionSecrets:n}=e;if(!(this.currentContext?.email||r.email))throw new a("Email is required","MISSING_EMAIL");let c=n.find(y=>y.provider==="turnkey");if(!c)throw new a("Turnkey keypair not found","MISSING_KEYPAIR");let p={mpcPrimaryId:"placeholder_primary_id",otpId:"placeholder_otp_id",otpCode:t,authPublicKey:c.publicKey},d=await this.gridApiClient.completeTurnkeyAuthAndCreateAccount(p);if(!d.success)throw new s(d.error||"Failed to complete Turnkey auth and create account","turnkey",d.code?parseInt(d.code):void 0);return d.data}determineAuthType(e){if(e.provider)return e.provider;if(e.email)return "privy";if(e.keypair)return "solana";if(e.passkeyId)return "passkey";throw new a("Unable to determine authentication type from request","AMBIGUOUS_AUTH_REQUEST")}getCurrentProvider(){return this.currentContext?.provider}getCurrentContext(){return this.currentContext}clearContext(){this.currentContext=void 0;}};u(Q,"AuthenticationManager");var C=Q;var qe={timeout:1e4,retryAttempts:3};function oe(o){let e=o?.apiKey;if(!e)throw new Error("API key is not set");return {...qe,apiKey:e,...o,baseUrl:o?.baseUrl||"https://grid.squads.xyz",environment:o?.environment||"sandbox",solanaRpcUrl:o?.solanaRpcUrl||"https://api.devnet.solana.com",timeout:o?.timeout||1e4,retryAttempts:o?.retryAttempts||3}}u(oe,"getGridConfig");var Ee={one_time:"one_time",daily:"day",weekly:"week",monthly:"month"};function U(o){let e=Ee[o];if(!e)throw new a("Invalid period","INVALID_REQUEST");return e}u(U,"gridToProgramPeriod");var M=class M{constructor(e,t){this.providerType=e;this.config=t;this.initialized=false;this.authState="unauthenticated";this.initializeApiClient();}initializeApiClient(){if(this.config.apiKey)try{this.gridApiClient=new P(oe({apiKey:this.config.apiKey,environment:this.config.environment}));}catch(e){throw new s(`Failed to initialize Grid API client: ${e.message}`,this.providerType,void 0,e)}}createProviderError(e,t,r){return new s(e,this.providerType,void 0,r,t?.details,t?.timestamp,t?.requestId)}async createSpendingLimit(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for setting spending limits",this.providerType);let r={amount:t.amount,mint:t.mint,period:U(t.period),transaction_signers:t.transaction_signers,spending_limit_signers:t.spending_limit_signers},n=await this.gridApiClient.createSpendingLimit(e,r);if(!n.success||!n.data)throw new s(n.error||"Failed to set spending limit",this.providerType,n.code?parseInt(n.code):void 0,void 0,n.details);return n.data}catch(r){throw r instanceof s?r:new s(`Failed to set spending limit: ${r.message}`,this.providerType,void 0,r,r.details)}}async updateSpendingLimit(e,t,r){try{if(!this.gridApiClient)throw new s("Grid API client is required for updating spending limit",this.providerType);let n=await this.gridApiClient.updateSpendingLimit(e,t,r);if(!n.success||!n.data)throw new s(n.error||"Failed to update spending limit",this.providerType,n.code?parseInt(n.code):void 0,void 0,n.details);return n.data}catch(n){throw n instanceof s?n:new s(`Failed to update spending limit: ${n.message}`,this.providerType,void 0,n,n.details)}}async deleteSpendingLimit(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for deleting spending limit",this.providerType);let r=await this.gridApiClient.deleteSpendingLimit(e,t);if(!r.success||!r.data)throw new s(r.error||"Failed to delete spending limit",this.providerType,r.code?parseInt(r.code):void 0,void 0,r.details);return r.data}catch(r){throw r instanceof s?r:new s(`Failed to delete spending limit: ${r.message}`,this.providerType,void 0,r,r.details)}}async useSpendingLimit(e,t,r){try{if(!this.gridApiClient)throw new s("Grid API client is required for using spending limit",this.providerType);let n=await this.gridApiClient.useSpendingLimit(e,t,r);if(!n.success||!n.data)throw new s(n.error||"Failed to use spending limit",this.providerType,n.code?parseInt(n.code):void 0,void 0,n.details);return n.data}catch(n){throw n instanceof s?n:new s(`Failed to use spending limit: ${n.message}`,this.providerType,void 0,n,n.details)}}async getPasskeys(e){try{if(!this.gridApiClient)throw new s("Grid API client is required for getting passkeys",this.providerType);let t=await this.gridApiClient.getPasskeys(e);if(!t.success||!t.data)throw new s(t.error||"Failed to get passkeys",this.providerType,t.code?parseInt(t.code):void 0,void 0,t.details);return t.data}catch(t){throw t instanceof s?t:new s(`Failed to get passkeys: ${t.message}`,this.providerType,void 0,t,t.details)}}async addPasskey(e,t,r){try{if(!this.gridApiClient)throw new s("Grid API client is required for adding passkey",this.providerType);let n=await this.gridApiClient.addPasskey(e,t,r);if(!n.success||!n.data)throw new s(n.error||"Failed to add passkey",this.providerType,n.code?parseInt(n.code):void 0,void 0,n.details);return n.data}catch(n){throw n instanceof s?n:new s(`Failed to add passkey: ${n.message}`,this.providerType,void 0,n,n.details)}}async createAccount(e){try{if(!this.gridApiClient)throw new s("Grid API client is required for creating account",this.providerType);let t=await this.gridApiClient.createAccount(e);if(!t.success||!t.data)throw new s(t.error||"Failed to create account",this.providerType,t.code?parseInt(t.code):void 0,void 0,t.details);return t.data}catch(t){throw t instanceof s?t:new s(`Failed to create account: ${t.message}`,this.providerType,void 0,t,t.details)}}async getAccount(e){try{if(!this.gridApiClient)throw new s("Grid API client is required for getting account",this.providerType);let t=await this.gridApiClient.getAccount(e);if(!t.success||!t.data)throw new s(t.error||"Failed to get account",this.providerType,t.code?parseInt(t.code):void 0,void 0,t.details);return t.data}catch(t){throw t instanceof s?t:new s(`Failed to get account: ${t.message}`,this.providerType,void 0,t,t.details)}}async getAccountBalances(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for getting account balances",this.providerType);let r=await this.gridApiClient.getAccountBalances(e,t);if(!r.success||!r.data)throw new s(r.error||"Failed to get account balances",this.providerType,r.code?parseInt(r.code):void 0,void 0,r.details);return r.data}catch(r){throw r instanceof s?r:new s(`Failed to get account balances: ${r.message}`,this.providerType,void 0,r,r.details)}}async getTransfers(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for getting transfers",this.providerType);let r=await this.gridApiClient.getTransfers(e,t);if(!r.success||!r.data)throw new s(r.error||"Failed to get transfers",this.providerType,r.code?parseInt(r.code):void 0,void 0,r.details);return r.data}catch(r){throw r instanceof s?r:new s(`Failed to get transfers: ${r.message}`,this.providerType,void 0,r,r.details)}}async updateAccount(e,t,r){try{if(!this.gridApiClient)throw new s("Grid API client is required for updating account",this.providerType);let n=await this.gridApiClient.updateAccount(e,t,r);if(!n.success||!n.data)throw new s(n.error||"Failed to update account",this.providerType,n.code?parseInt(n.code):void 0,void 0,n.details);return n.data}catch(n){throw n instanceof s?n:new s(`Failed to update account: ${n.message}`,this.providerType,void 0,n,n.details)}}async createPaymentIntent(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for creating payment intent",this.providerType);let r=await this.gridApiClient.createPaymentIntent(e,t);if(!r.success||!r.data)throw new s(r.error||"Failed to create payment intent",this.providerType,r.code?parseInt(r.code):void 0,void 0,r.details);return r.data}catch(r){throw r instanceof s?r:new s(`Failed to create payment intent: ${r.message}`,this.providerType,void 0,r,r.details)}}async requestKycLink(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for requesting KYC link",this.providerType);let r=await this.gridApiClient.requestKycLink(e,t);if(!r.success||!r.data)throw new s(r.error||"Failed to request KYC link",this.providerType,r.code?parseInt(r.code):void 0,void 0,r.details);return r.data}catch(r){throw r instanceof s?r:new s(`Failed to request KYC link: ${r.message}`,this.providerType,void 0,r,r.details)}}async getKycStatus(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for getting KYC status",this.providerType);let r=await this.gridApiClient.getKycStatus(e,t);if(!r.success||!r.data)throw new s(r.error||"Failed to get KYC status",this.providerType,r.code?parseInt(r.code):void 0,void 0,r.details);return r.data}catch(r){throw r instanceof s?r:new s(`Failed to get KYC status: ${r.message}`,this.providerType,void 0,r,r.details)}}async prepareArbitraryTransaction(e,t,r){try{if(!this.gridApiClient)throw new s("Grid API client is required for preparing arbitrary transaction",this.providerType);let n=t.transaction_signers||t.account_signers||[];t.transaction_signers=n;let i=await this.gridApiClient.prepareArbitraryTransaction(e,t,r);if(!i.success||!i.data)throw this.createProviderError(i.error||"Failed to prepare arbitrary transaction",i);return i.data}catch(n){throw n instanceof s?n:new s(`Failed to prepare arbitrary transaction: ${n.message}`,this.providerType,void 0,n,n.details)}}async removePasskey(e,t,r,n){try{if(!this.gridApiClient)throw new s("Grid API client is required for removing passkey",this.providerType);let i=await this.gridApiClient.removePasskey(e,t,r,n);if(!i.success||!i.data)throw new s(i.error||"Failed to remove passkey",this.providerType,i.code?parseInt(i.code):void 0,void 0,i.details);return i.data}catch(i){throw i instanceof s?i:new s(`Failed to remove passkey: ${i.message}`,this.providerType,void 0,i,i.details)}}async requestVirtualAccount(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for requesting virtual account",this.providerType);let r=await this.gridApiClient.requestVirtualAccount(e,t);if(!r.success||!r.data)throw new s(r.error||"Failed to request virtual account",this.providerType,r.code?parseInt(r.code):void 0,void 0,r.details);return r.data}catch(r){throw r instanceof s?r:new s(`Failed to request virtual account: ${r.message}`,this.providerType,void 0,r,r.details)}}async getVirtualAccounts(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for getting virtual accounts",this.providerType);let r=await this.gridApiClient.getVirtualAccounts(e,t);if(!r.success||!r.data)throw new s(r.error||"Failed to get virtual accounts",this.providerType,r.code?parseInt(r.code):void 0,void 0,r.details);return r.data}catch(r){throw r instanceof s?r:new s(`Failed to get virtual accounts: ${r.message}`,this.providerType,void 0,r,r.details)}}async createStandingOrder(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for standing order creation",this.providerType);let r=await this.gridApiClient.createStandingOrder(e,t);if(!r.success||!r.data)throw new s(r.error||"Failed to create standing order",this.providerType);return r.data}catch(r){throw r instanceof s?r:new s(`Failed to create standing order: ${r.message}`,this.providerType,void 0,r)}}async getStandingOrders(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for standing orders retrieval",this.providerType);let r=await this.gridApiClient.getStandingOrders(e,t);if(!r.success||!r.data)throw new s(r.error||"Failed to get standing orders",this.providerType);return r.data}catch(r){throw r instanceof s?r:new s(`Failed to get standing orders: ${r.message}`,this.providerType,void 0,r)}}async getStandingOrder(e,t){try{if(!this.gridApiClient)throw new s("Grid API client is required for standing order retrieval",this.providerType);let r=await this.gridApiClient.getStandingOrder(e,t);if(!r.success||!r.data)throw new s(r.error||"Failed to get standing order",this.providerType);return r.data}catch(r){throw r instanceof s?r:new s(`Failed to get standing order: ${r.message}`,this.providerType,void 0,r)}}};u(M,"AbstractBaseProvider");var T=M;var f=new Uint8Array([72,80,75,69,45,118,49]),ce=new Uint8Array([75,69,77,0,16]),_=new Uint8Array([72,80,75,69,0,16,0,1,0,3]),Le=new Uint8Array([101,97,101,95,112,114,107]),Oe=new Uint8Array([115,104,97,114,101,100,95,115,101,99,114,101,116]),De=new Uint8Array([115,101,99,114,101,116]),Be=new Uint8Array([98,97,115,101,95,110,111,110,99,101]),Ne=u((o,e=true)=>p256.p256.getPublicKey(o,e),"getPublicKey");var Fe=u(async({ciphertextBuf:o,encappedKeyBuf:e,receiverPriv:t})=>{try{let r=He(e,t),n=Ne(encoding.uint8ArrayFromHexString(t),!1),i=new Uint8Array(e.length+n.length);i.set(e,0),i.set(n,e.length);let c=Ve(Le,r,ce),p=Qe(Oe,i,ce,32),d=Me(new Uint8Array([]),c,p,32),y=new Uint8Array([0]),g=new Uint8Array,l=new Uint8Array,m=new Uint8Array,A=await pe(new ArrayBuffer(0),new Uint8Array([112,115,107,95,105,100,95,104,97,115,104]),l,_),O=await pe(new ArrayBuffer(0),new Uint8Array([105,110,102,111,95,104,97,115,104]),m,_),h=new Uint8Array(65);h.set(y,0),h.set(new Uint8Array(A),1),h.set(new Uint8Array(O),33);let S=me(De,g,_),fe=de(new Uint8Array([107,101,121]),h,_,32),Ae=await ue(d.buffer,S.buffer,fe.buffer,32),Pe=de(Be,h,_,12),Re=await ue(d.buffer,S.buffer,Pe.buffer,12);return We(o,new Uint8Array(Ae),new Uint8Array(Re),void 0)}catch(r){throw new Error(`Unable to perform hpkeChachaDecrypt: ${r} `)}},"hpkeChachaDecrypt"),le=u(async(o,e)=>{try{let t=H(o.encapsulated_key),r=H(o.ciphertext),n=H(e),i=$e(n),c=encoding.uint8ArrayToHexString(i);return await Fe({ciphertextBuf:r,encappedKeyBuf:t,receiverPriv:c})}catch(t){throw new Error(`React Native HPKE ChaCha decrypt failed: ${t}`)}},"hpkeChachaDecryptRN");var $e=u(o=>o.slice(36,68),"extractPrivateKeyFromPKCS8Bytes");var Ve=u((o,e,t)=>{let r=f.length+t.length+o.length+e.length,n=new Uint8Array(r),i=0;return n.set(f,i),i+=f.length,n.set(t,i),i+=t.length,n.set(o,i),i+=o.length,n.set(e,i),n},"buildHpkeCoreLabeledIkm"),Qe=u((o,e,t,r)=>{let n=new Uint8Array(2+f.length+t.length+o.length+e.length),i=0;return n.set(new Uint8Array([r>>8,r&255]),i),i+=2,n.set(f,i),i+=f.length,n.set(t,i),i+=t.length,n.set(o,i),i+=o.length,n.set(e,i),n},"buildHpkeCoreLabeledInfo"),me=u((o,e,t)=>{let r=new Uint8Array(7+t.byteLength+o.byteLength+e.byteLength);return r.set(f,0),r.set(t,7),r.set(o,7+t.byteLength),r.set(e,7+t.byteLength+o.byteLength),r},"buildWebCryptoLabeledIkm"),de=u((o,e,t,r)=>{let n=new Uint8Array(9+t.byteLength+o.byteLength+e.byteLength);return n.set(new Uint8Array([0,r]),0),n.set(f,2),n.set(t,9),n.set(o,9+t.byteLength),n.set(e,9+t.byteLength+o.byteLength),n},"buildWebCryptoLabeledInfo"),ue=u(async(o,e,t,r)=>{let n=new Uint8Array(o),i=new Uint8Array(e),c=new Uint8Array(t),p=w__namespace.extract(sha256.sha256,i,n),d=w__namespace.expand(sha256.sha256,p,c,r);return d.buffer.slice(d.byteOffset,d.byteOffset+d.byteLength)},"webCryptoExtractAndExpand"),pe=u(async(o,e,t,r)=>{let n=me(e,t,r),i=o.byteLength===0?new Uint8Array(32):new Uint8Array(o),c=w__namespace.extract(sha256.sha256,n,i);return c.buffer.slice(c.byteOffset,c.byteOffset+c.byteLength)},"webCryptoLabeledExtract");var Me=u((o,e,t,r)=>{let n=w__namespace.extract(sha256.sha256,e,o),i=w__namespace.expand(sha256.sha256,n,t,r);return new Uint8Array(i)},"extractAndExpand"),He=u((o,e)=>p256.p256.getSharedSecret(encoding.uint8ArrayFromHexString(e),o).slice(1),"deriveSS");var We=u((o,e,t,r)=>chacha.chacha20poly1305(e,t,r).decrypt(o),"chachaDecrypt");var H=u(o=>{let e=atob(o),t=new Uint8Array(e.length);for(let r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t},"base64ToUint8Array");var W=class W extends T{constructor(e){super("privy",e),this.privyConfig=e;}async generateLocalKeyPair(){try{let e=await K();return {publicKey:e.publicKey,privateKey:e.privateKey}}catch(e){throw new s(`Failed to generate local Privy key pair: ${e.message}`,"privy",void 0,e)}}async generateUniversalKeyPair(){let e=await this.generateLocalKeyPair();return {publicKey:e.publicKey,privateKey:e.privateKey}}async initiateAuth(e){try{if(!this.config.apiKey)throw new s("API key is required for Privy authentication. Provide apiKey in config for API operations.","privy");if(!e.email)throw new s("Email is required for Privy authentication","privy");let r=await this.gridApiClient.initAuthWithPrivy(e);if(!r.success)throw new s(r.error||"Privy authentication failed","privy",r.code?parseInt(r.code):void 0,void 0,r.details);let n=r.data;return {data:{accountType:n.data.type,email:n.data.email,status:n.data.status,otpSent:n.data.otp_sent,createdAt:n.data.created_at,expiresAt:n.data.expires_at},metadata:r.data.metadata}}catch(t){if(t instanceof s)throw t;let r=t instanceof Error?t.message:"Unknown error";throw new s(`Privy authentication failed: ${r}`,"privy",void 0,t instanceof Error?t:void 0)}}async initAuth(e){try{if(!e)throw new s("Email is required for Privy auth creation","privy");let t=await this.gridApiClient.initAuthWithPrivy({email:e});if(!t.success)throw new s(t.error||"Failed to create Privy auth","privy",t.code?parseInt(t.code):void 0,void 0,t.details);return {...t.data}}catch(t){if(t instanceof s)throw t;let r=t instanceof Error?t.message:"Unknown error";throw new s(`Failed to create Privy auth: ${r}`,"privy",void 0,t instanceof Error?t:void 0)}}async completeAuthAndCreateAccount(e){try{if(!this.config.apiKey)throw new s("API key is required for Privy authentication. Provide apiKey in config for API operations.","privy");let r=await this.gridApiClient.completePrivyAuthAndCreateAccount(e);if(!r.success)throw new s(r.error||"Privy authentication completion failed","privy",r.code?parseInt(r.code):void 0,void 0,r.details);return r.data}catch(t){if(t instanceof s)throw t;let r=t instanceof Error?t.message:"Unknown error";throw new s(`Privy authentication failed: ${r}`,"privy",void 0,t instanceof Error?t:void 0)}}async completeAuth(e){try{if(!this.config.apiKey)throw new s("API key is required for Privy authentication. Provide apiKey in config for API operations.","privy");let r=await this.gridApiClient.completePrivyAuth(e);if(!r.success)throw new s(r.error||"Privy authentication completion failed","privy",r.code?parseInt(r.code):void 0,void 0,r.details);return r.data}catch(t){if(t instanceof s)throw t;let r=t instanceof Error?t.message:"Unknown error";throw new s(`Privy authentication failed: ${r}`,"privy",void 0,t instanceof Error?t:void 0)}}async sign(e){let{transaction:t,signers:r,authorizationKey:n}=e,i=r[0];if(!i||!("privateKey"in i))throw new s("Privy provider requires UniversalKeyPair format. Solana Keypairs should be auto-routed to Solana provider.","privy");if(e.signers.length>1)throw new s("Privy provider does not support multiple signers","privy");try{let c=await le(n,i.privateKey),p=new TextDecoder().decode(c);return q(t,p)}catch(c){let p=c instanceof Error?c.message:"Unknown error";throw new s(`Privy signing failed: ${p}`,"privy",void 0,c instanceof Error?c:void 0)}}async send(e){}async signAndSend(e){throw new s("Privy provider does not support signing and sending transactions in one step","privy")}};u(W,"PrivyProvider");var G=W;var z=class z extends T{constructor(e){super("turnkey",e),this.turnkeyConfig=e;}async generateLocalKeyPair(){try{return await E()}catch(e){throw new s(`Failed to generate local Turnkey key pair: ${e.message}`,"turnkey",void 0,e)}}async generateUniversalKeyPair(){let e=await this.generateLocalKeyPair();return {publicKey:e.publicKey,privateKey:e.privateKey,publicKeyUncompressed:e.publicKeyUncompressed}}async initiateAuth(e){try{if(!this.config.apiKey)throw new s("API key is required for Turnkey authentication. Provide apiKey in config for API operations.","turnkey");if(!e.email)throw new s("Email is required for Turnkey authentication","turnkey");let r=await this.gridApiClient.initAuthWithTurnkey(e);if(!r.success)throw new s(r.error||"Turnkey authentication failed","turnkey",r.code?parseInt(r.code):void 0);let n=r.data;return {data:{mpcPrimaryId:n.data.mpc_primary_id,otpId:n.data.otp_id},metadata:r.data.metadata}}catch(t){throw t instanceof s?t:new s(`Turnkey authentication failed: ${t.message}`,"turnkey",void 0,t)}}async completeAuthAndCreateAccount(e){throw new s("Turnkey completeAuthAndCreateAccount not yet implemented","turnkey")}async completeAuth(e){try{if(!this.config.apiKey)throw new s("API key is required for Turnkey authentication. Provide apiKey in config for API operations.","turnkey");return (await this.gridApiClient.completeTurnkeyAuth(e)).data}catch(t){throw t instanceof s?t:new s(`Turnkey authentication failed: ${t.message}`,"turnkey",void 0,t)}}async sign(e){let{transaction:t,signers:r,credentials:n}=e,i=r[0];if(!i||!("privateKey"in i))throw new s("Turnkey provider requires UniversalKeyPair format. Solana Keypairs should be auto-routed to Solana provider.","turnkey");if(e.signers.length>1)throw new s("Turnkey provider does not support multiple signers","turnkey");let p=await ie(n,i.privateKey),d=await se(p),y=await ae({payload:JSON.stringify(t),privateKey:p});return JSON.stringify({requestParameters:t,stamp:{publicKey:d,signature:y}})}async send(e){try{return {}}catch(t){throw new s(`Turnkey send failed: ${t.message}`,"turnkey",void 0,t)}}async signAndSend(e){throw new s("Turnkey provider does not support signing and sending transactions","turnkey")}};u(z,"TurnkeyProvider");var L=z;var j=class j{constructor(e){this.gridApiClient=e;}getUnsignedSigners(e,t){try{let r=Buffer.from(e,"base64"),n=web3_js.VersionedTransaction.deserialize(r),i=n.message.staticAccountKeys,c=n.signatures;return t.filter(p=>{try{let d=new web3_js.PublicKey(p),y=i.findIndex(m=>m.equals(d));if(y===-1)return !1;let g=c[y];return !(g!==null&&g.length>0&&!this.isEmptySignature(g))}catch{return !1}})}catch{return t}}isEmptySignature(e){return e.length!==64?true:e.every(t=>t===0)}hasPublicKeySigned(e,t){try{let r=Buffer.from(e,"base64"),n=web3_js.VersionedTransaction.deserialize(r),i=n.message.staticAccountKeys,c=n.signatures,p=new web3_js.PublicKey(t),d=i.findIndex(l=>l.equals(p));if(d===-1)return !1;let y=c[d];return y!==null&&y.length>0&&!this.isEmptySignature(y)}catch{return  false}}async sign(e){let t=e.transactionPayload.transaction,r=e.transactionPayload.transaction_signers,n=e.transactionPayload.kms_payloads,{sessionSecrets:i,session:c}=e;if(!t&&!n)throw new a("Payload is required for signing","MISSING_PAYLOAD");if(!i||i.length===0)throw new a("At least one keypair is required for signing","NO_KEYPAIRS");let p=[],d=t,y=this.getUnsignedSigners(t,r);if(r.length>y.length){r.filter(m=>!y.includes(m));}return y.length===0?{transaction:d,kms_payloads:p}:(await Promise.all(y.map(async l=>{if(n&&n.length>0){let m=n.find(A=>A.address===l);if(m)switch(m.provider){case "privy":let A=i.find(S=>S.provider==="privy"),O=await this.signWithPrivyProvider(m.payload,A,c);p.push({provider:"privy",signature:O});break;case "external":let h=i.find(S=>S.publicKey.toString()===l);if(!h)throw new a(`No keypair found for external signer: ${l}`,"KEYPAIR_NOT_FOUND");d=await this.signWithSolanaProvider(t,h);break;default:throw new a("Unsupported provider for signing","UNSUPPORTED_PROVIDER")}}else {let m=i.find(A=>A.publicKey.toString()===l);if(!m)throw new a(`No keypair found for external signer: ${l}`,"KEYPAIR_NOT_FOUND");d=await this.signWithSolanaProvider(t,m);}})),{transaction:d,kms_payloads:p})}async signWithPrivyProvider(e,t,r){if(r&&r.length>0){let i=r.find(c=>c.session?.Privy);if(i?.session?.Privy?.session?.encrypted_authorization_key){let c=i.session.Privy.session.encrypted_authorization_key,p={transaction:typeof e=="string"?e:JSON.stringify(e),sessionSecrets:[t],signers:[t],authorizationKey:c};return await new G({}).sign(p)}}if(!t.privateKey)throw new a("Private key required for Privy signing without session","MISSING_PRIVATE_KEY");return q(typeof e=="string"?e:JSON.stringify(e),t.privateKey)}async signWithTurnkeyProvider(e,t,r){if(!t.privateKey)throw new a("Private key required for Turnkey signing","MISSING_PRIVATE_KEY");let n={transaction:typeof e=="string"?e:JSON.stringify(e),sessionSecrets:[t],signers:[t],credentials:""};return {provider:"turnkey",signature:await new L({}).sign(n),publicKey:t.publicKey,timestamp:r}}async signWithSolanaProvider(e,t){try{let r=Buffer.from(e,"base64"),n=web3_js.VersionedTransaction.deserialize(r);n.sign([t]);let i=n.serialize();return Buffer.from(i).toString("base64")}catch(r){throw new a(`Failed to sign with Solana provider: ${r.message}`,"SIGNING_FAILED")}}async signWithPasskeyProvider(e,t,r){throw new a("Passkey signing not yet implemented","NOT_IMPLEMENTED")}selectKeypairsFromSession(e,t,r){if(r&&r.length>0&&t&&t.length>0)return this.selectKeypairsFromTransactionSigners(e,t,r);if(!t||t.length===0){let i=e.filter(c=>c.provider==="solana"||c.provider==="passkey");return i.length>0?i:e}let n=[];for(let i of t){if(i.provider==="privy"||i.session?.Privy){let p=i.session?.Privy?.session?.wallets||[],y=e.filter(g=>g.provider!=="privy"?false:p.some(m=>m.address===g.publicKey||m.public_key===g.publicKey)).sort((g,l)=>{let m={primary:1,backup:2,solana:3,passkey:4};return (m[g.tag]||99)-(m[l.tag]||99)});if(y.length>0){let g=y[0];n.includes(g)||n.push(g);}}if(i.provider==="turnkey"||i.session?.Turnkey){i.session?.Turnkey;let d=e.filter(y=>y.provider==="turnkey").sort((y,g)=>{let l={primary:1,backup:2,solana:3,passkey:4};return (l[y.tag]||99)-(l[g.tag]||99)});if(d.length>0){let y=d[0];n.includes(y)||n.push(y);}}}if(n.length===0){let i=e.filter(c=>c.provider==="solana"||c.provider==="external");i.length>0&&(n=i);}if(n.length===0){let i=e.filter(c=>c.tag==="primary");n=i.length>0?i:e;}return n}selectKeypairsFromTransactionSigners(e,t,r){let n=[];for(let i of r){let c=null;for(let p of t)if((p.provider==="privy"||p.session?.Privy)&&(p.session?.Privy?.session?.wallets||[]).some(l=>l.address===i)){c="privy";break}if(c){let d=e.filter(y=>y.provider===c).sort((y,g)=>{let l={primary:1,backup:2,solana:3,passkey:4};return (l[y.tag]||99)-(l[g.tag]||99)});if(d.length>0){let y=d[0];n.includes(y)||n.push(y);}}}return n}aggregateSignatures(e){}};u(j,"SigningManager");var I=j;var X=class X{createAuthError(e,t,r){return new a(e,t,void 0,void 0,r?.details,r?.timestamp,r?.requestId)}constructor(e){this.apiConfig=e,this.apiClient=new P(e),this.authManager=new C(this.apiClient),this.signingManager=new I(this.apiClient),this.solanaRpcUrl=e.solanaRpcUrl,this.context={client:{environment:this.apiConfig.environment,config:this.apiConfig,solanaRpcUrl:this.solanaRpcUrl},user:{signers:[]}};}extractSignableTransaction(e){let t=Buffer.from(e.data.transaction,"base64");return web3_js.VersionedTransaction.deserialize(t)}setExternallySignedTransaction(e,t){return {data:{transaction:Buffer.from(t.serialize()).toString("base64"),transaction_signers:e.data.transaction_signers,kms_payloads:e.data.kms_payloads}}}async initAuth(e){try{let t={email:e.email,keypair:e.keypair,passkeyId:e.passkeyId,provider:e.provider,expiration:e.expiration};return await this.authManager.authenticate(t)}catch(t){throw t instanceof a?t:new a(`Authentication initialization failed: ${t.message}`,"AUTH_INIT_FAILED")}}async completeAuth(e){try{return await this.authManager.complete(e)}catch(t){throw t instanceof a?t:new a(`Authentication completion failed: ${t.message}`,"AUTH_COMPLETE_FAILED")}}async completeAuthAndCreateAccount(e){try{let t=await this.authManager.completeAndCreateAccount(e);return t?.address&&(this.context.user.address=t.address),t}catch(t){throw t instanceof a?t:new a(`Account creation failed: ${t.message}`,"ACCOUNT_CREATE_FAILED")}}async generateSessionSecrets(){return await this.authManager.generateSessionSecrets()}async generateKeyPair(e){let t=e||"privy";return await this.authManager.generateKeyPair(t)}async sign(e){try{return await this.signingManager.sign(e)}catch(t){throw t instanceof a?t:new a(`Signing failed: ${t.message}`,"SIGNING_FAILED")}}async signAndSend(e){try{let t={sessionSecrets:e.sessionSecrets,transactionPayload:e.transactionPayload,session:e.session},r=await this.signingManager.sign(t);return await this.send({address:e.address,signedTransactionPayload:r})}catch(t){throw t instanceof a?t:new a(`Signing failed: ${t.message}`,"SIGNING_FAILED")}}async send(e){let{signedTransactionPayload:t,address:r}=e,{transaction:n,kms_payloads:i}=t;if(!n)throw new a("Transaction is required","MISSING_TRANSACTION");if(!r)throw new a("Address is required","MISSING_ADDRESS");let c={transaction:n,kms_payloads:i},p=await this.apiClient.submitTransaction(r,c);if(!p.success||!p.data)throw this.createAuthError(p.error||"Transaction submission failed","SUBMIT_FAILED",p);return p.data}async createAccount(e){let t;"type"in e?t=e:t=this.constructAccountPayload(e);let r=await this.apiClient.createAccount(t);if(!r.success||!r.data)throw this.createAuthError(r.error||"Failed to create account","API_ERROR",r);return r.data.type==="signers"&&r.data.address?this.context.user.address=r.data.address:r.data.type==="email"&&r.data.email&&(this.context.user.email=r.data.email),r.data}async getAccount(e){if(!e)throw new a("Account address is required","INVALID_REQUEST");let t=await this.apiClient.getAccount(e);return !t.success||!t.data?{success:false,error:t.error||"Failed to get account"}:t}async updateAccount(e,t,r){if(!e)throw new a("Account address is required","INVALID_REQUEST");let n=await this.apiClient.updateAccount(e,t,r);if(!n.success||!n.data)throw new a(n.error||"Failed to update account","API_ERROR");return n}async getAccountBalances(e,t){if(!e)throw new a("Account address is required","INVALID_REQUEST");let r=await this.apiClient.getAccountBalances(e,t);return r.success?r:{success:false,error:r.error||"Failed to get account balances"}}async getTransfers(e,t){if(!e)throw new a("Account address is required","INVALID_REQUEST");let r=await this.apiClient.getTransfers(e,t);if(!r.success||!r.data)throw new a(r.error||"Failed to get transfers","API_ERROR");return r}async createSpendingLimit(e,t){if(!e)throw new a("Account address is required","INVALID_REQUEST");let r={amount:t.amount,mint:t.mint,period:U(t.period),transaction_signers:t.transaction_signers,spending_limit_signers:t.spending_limit_signers},n=await this.apiClient.createSpendingLimit(e,r);if(!n.success||!n.data)throw new a(n.error||"Failed to set spending limit","API_ERROR");return n}async updateSpendingLimit(e,t,r){if(!e||!t)throw new a("Account and spending limit addresses are required","INVALID_REQUEST");let n=await this.apiClient.updateSpendingLimit(e,t,r);if(!n.success||!n.data)throw new a(n.error||"Failed to update spending limit","API_ERROR");return n}async deleteSpendingLimit(e,t){if(!e||!t)throw new a("Account and spending limit addresses are required","INVALID_REQUEST");let r=await this.apiClient.deleteSpendingLimit(e,t);if(!r.success||!r.data)throw new a(r.error||"Failed to delete spending limit","API_ERROR");return r}async useSpendingLimit(e,t,r){if(!e||!t)throw new a("Account and spending limit addresses are required","INVALID_REQUEST");let n=await this.apiClient.useSpendingLimit(e,t,r);if(!n.success||!n.data)throw new a(n.error||"Failed to use spending limit","API_ERROR");return n}async getPasskeys(e){if(!e)throw new a("Account address is required","INVALID_REQUEST");let t=await this.apiClient.getPasskeys(e);if(!t.success||!t.data)throw new a(t.error||"Failed to get passkeys","API_ERROR");return t.data}async addPasskey(e,t,r){if(!e)throw new a("Account address is required","INVALID_REQUEST");let n=await this.apiClient.addPasskey(e,t,r);if(!n.success||!n.data)throw new a(n.error||"Failed to add passkey","API_ERROR");return n.data}async removePasskey(e,t,r,n){if(!e||!t)throw new a("Account and passkey addresses are required","INVALID_REQUEST");let i=await this.apiClient.removePasskey(e,t,r,n);if(!i.success||!i.data)throw new a(i.error||"Failed to remove passkey","API_ERROR");return i.data}async createPaymentIntent(e,t){if(!e)throw new a("Account address is required","INVALID_REQUEST");let r=await this.apiClient.createPaymentIntent(e,t);if(!r.success||!r.data)throw new a(r.error||"Failed to create payment intent","API_ERROR");let n=r.data.data||r.data,i={kms_payloads:n.kms_payloads,transaction_signers:n.transaction_signers,transaction:n.transaction},{kms_payloads:c,transaction_signers:p,transaction:d,...y}=n;return {data:{...y,transactionPayload:i}}}async requestKycLink(e,t){if(!e)throw new a("Account address is required","INVALID_REQUEST");let r=await this.apiClient.requestKycLink(e,t);if(!r.success||!r.data)throw new a(r.error||"Failed to request KYC link","API_ERROR");return r}async getKycStatus(e,t){if(!e||!t)throw new a("Account address and KYC ID are required","INVALID_REQUEST");let r=await this.apiClient.getKycStatus(e,t);return r.success?r:{success:false,error:r.error||"Failed to get KYC status"}}async prepareArbitraryTransaction(e,t,r){if(!e)throw new a("Account address is required","INVALID_REQUEST");let n=await this.apiClient.prepareArbitraryTransaction(e,t,r);if(!n.success||!n.data)throw this.createAuthError(n.error||"Failed to prepare arbitrary transaction","API_ERROR",n);let i=n.data;return !i.kms_payloads&&!n.data.error&&(i.kms_payloads=[]),{data:i}}async requestVirtualAccount(e,t){if(!e)throw new a("Account address is required","INVALID_REQUEST");let r=await this.apiClient.requestVirtualAccount(e,t);if(!r.success||!r.data)throw new a(r.error||"Failed to request virtual account","API_ERROR");return r}async getVirtualAccounts(e,t){if(!e)throw new a("Account address is required","INVALID_REQUEST");let r=await this.apiClient.getVirtualAccounts(e,t);if(!r.success||!r.data)throw new a(r.error||"Failed to get virtual accounts","API_ERROR");return r.data}async createStandingOrder(e,t){if(!e)throw new a("Account address is required","INVALID_REQUEST");let r=await this.apiClient.createStandingOrder(e,t);return !r.success||!r.data?{...r.data,error:r.error}:r.data}async getStandingOrders(e,t){if(!e)throw new a("Account address is required","INVALID_REQUEST");let r=await this.apiClient.getStandingOrders(e,t);return !r.success||!r.data?{success:false,error:r.error||"Failed to get standing orders"}:r}async getStandingOrder(e,t){if(!e||!t)throw new a("Account address and standing order ID are required","INVALID_REQUEST");let r=await this.apiClient.getStandingOrder(e,t);return !r.success||!r.data?{success:false,error:r.error||"Failed to get standing order"}:r}getContext(){return this.context}updateContext(e){this.context.user={...this.context.user,...e};}clearAuthContext(){this.authManager.clearContext();}constructAccountPayload(e){if(!e.email&&!e.signer)throw new a("Must provide either email or signer","INVALID_REQUEST");if(e.email&&e.signer)throw new a("Cannot provide both email and signer","AMBIGUOUS_REQUEST");if(e.email){if(!v.isValidEmail(e.email))throw new a("Invalid email format","INVALID_EMAIL");return {type:"email",email:e.email}}if(e.signer){if(e.signer.length<32||e.signer.length>44)throw new a("Invalid signer address format","INVALID_REQUEST");return {type:"signers",policies:{signers:[{address:e.signer,role:"primary",permissions:["CAN_INITIATE","CAN_EXECUTE","CAN_VOTE"],provider:"external"}],threshold:1,time_lock:null,admin_address:null},grid_user_id:null,memo:void 0}}throw new a("Invalid input parameters","INVALID_REQUEST")}};u(X,"GridClient");var J=X;
exports.AuthenticationManager=C;exports.AuthorizationError=a;exports.GridApiClient=P;exports.GridClient=J;exports.ProviderError=s;exports.SigningManager=I;//# sourceMappingURL=index.js.map
//# sourceMappingURL=index.js.map